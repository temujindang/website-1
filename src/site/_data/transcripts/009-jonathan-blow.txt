[music]
00:00:12 Bryan Cantrill: Welcome to On the Metal, tales of from the hardware/software interface. I'm Bryan Cantrill with me as always is Jess Frazelle. Hey, Jess.
00:00:19 Jess Frazelle: Hey, Bryan.
00:00:20 Bryan: Joining us in the garage as well as our boss Steve Tuck. Hey, Steve.
00:00:22 Steve Tuck: Thank you for having me.
00:00:24 Bryan: All right. Jess, you want to introduce who we got in the garage today?
00:00:28 Jess: Yes. Today we have Jonathan Blow who created The Witness and other games, and I played The Witness. I'm actually a huge fan.
00:00:36 Bryan: Nice. Jonathan, welcome to the garage.
00:00:38 Jonathan Blow: Thanks. I did not create The Witness single-handedly. Of course, we had a team of people making that. It's actually a classic thing in the video game industry, it's like people like to identify things with one person when it's actually, it's hard making these things. I'm glad you played the game and hopefully got something out of it.
00:00:58 Bryan: Jonathan, it's great to have you here because we've had a bunch of folks on here on the podcast who have spent their life at the hardware/software interface delivering compute to other people. You're actually using compute to deliver an actual experience to an end user. You got a different perspective but very much trying to use hardware.
When you and I first met, one of the questions I asked you was, "Out of curiosity, how much hardware capacity would you use?" You told me, "I will use anything. I will use as much as you give me I got use for," which I thought was really interesting.
00:01:39 Jonathan: Yes, for sure. Video games have plenty of ideas about things that we would like to do that we don't know how to do yet. Unfortunately, a lot of those ideas-- The more concrete flavors of those ideas are all in the same direction like visuals, what things look like. If video games have a body, we've been working out the biceps for a long time, because those make money easily or something. There's all sorts of other things too. If you look at games these days, there are a lot of areas that are not directly, the pixels on the screen, that get underrepresented in terms of technical effort so far like animation or something, even audio.
The way audio processing happens. A video game is usually relatively low tech compared to the graphic. We're starting to beef it up. The thing that makes games so hard is there are many, many, many different categories of work. They all have to come together to make the final thing. Everyone one of those is indefinitely fractally complex if you get really serious about doing a good job at it. Then of course, that just means bad things in terms of your to-do list if you're trying to build one of these things.
00:02:54 Bryan: You said that about the animation for example. Because I remember the Prince of Persia when I was kid, was just mind-blowing. Even though the graphics were simple, the animation was so amazing.
00:03:07 Jonathan: Sometimes things are easy until they're not. The thing about Prince of Persia was it's a 2D game, you're viewing it from the side. The reason it was nicely animated was because it was one of the first games where the author actually cared about animation a great deal and had this idea like, "Let's actually draw out these things and get them into the game." The technical job to be done back then by modern standards was relatively simple. Back then, it was a little bit harder because less capable computers, you had to work harder to get all these pixels on the screen and stuff. Essentially, you've got a 2D sprite, and you're flipping through it.
You just make sure the content of that sprite is really good. That's job number one. Then job number two is just the timing of when things happen. You just try to make sure that's good. Now, in a current game. You might have a character moving around in a 3D world, so objects are 3D, so they're more complicated. They have a lot more degrees of freedom. You expect them to move, different parts of an object to move separately. It's a very different thing from having a sprite with some data baked in that you're just flipping pages on. In general, because of this increase complexity. You have more of an interaction between things in their environments, and you can't really get away with the same stuff anymore.
In Prince of Persia, I'm having a little bit of difficulty calling up exactly what the screen looks like. In all games of this kind, you treat the character as a box or something. You do collision with the environment by saying like, "Does this box overlap with other boxes?" For example. Some games would do pixel accurate collision detection, but sometimes you don't actually want that. I'm not sure exactly which one this game did, but either version of that is a relatively simple problem. In 3D, you can't really do that for various reasons. If I'm walking around on the ground, and there's like a tiny rock on the ground that's sticking up, and I'm colliding with it and I can't go.
It looks to a player like there's just some kind of invisible wall. They feel terrible. Just the degree of work that you have to do is just a lot. I'm not explaining it well enough yet, but it would probably take an hour to just explain that point.
00:05:25 Bryan: Work from computational work?
00:05:28 Jonathan: Yes. Just taking something like let's detect the collision between something in its environment as an example. Back in old style computers, there were ways of accelerating that even on home computers. I never had an Atari home computer.
00:05:47 Bryan: Oh, really? Wow.
00:05:48 Jonathan: I was a Commodore 64, TRS-80 guy when I was in high school. Compared to your previous guess, that's recent history.
00:05:59 Bryan: You and I are on the same vintage. I did have an Atari 2600.
00:06:07 Jonathan: A 2600, I had. I mean the computers.
00:06:10 Bryan: The 800.
00:06:11 Jonathan: The 800, and whatever the other one was. Those I believe had collision registers you could query. You would draw a sprite, and then you could ask what pixels of this sprite hit pixels of this other sprite or something. That was a way of speeding up this problem. That works fine if you're doing [crosstalk]
00:06:31 Bryan: The Atari 800 had that.
00:06:33 Jonathan: Something happened.
00:06:34 Bryan: A third had the Atari 800.
00:06:39 Jonathan: Maybe actually the Commodore 64 had that. I don't know. It's just to say that that was the scale of technical problem at that time. People didn't even really do box versus box that much. It was either box versus extents or sprite versus sprite. I think Commodore 64 did that. This is showing you how much I remember. I program that thing for years.
[laughter]
Jonathan: I don't remember even what it did. These days, it's a very, very, very different problems. First of all, before you're even going to collide something, you need to have something. Let's say I have a person walking around like a lot of games do. How do you do that? You could imagine, for example, and the earliest 3D games do is you could, example, that much like you do sprites by having like a flip book of images. You could have some poses of a person doing a walk, and you somehow represent the geometry in all these poses, and you flip through it. Very early 3D games. Quake one did this, for example. It doesn't do it anymore.
Anyway, that has a lot of drawbacks. How do you represent the geometry? You have points and space. There's like a 3D coordinate for every vertex, and then you have what's called an index array which is just like, "Let's define a bunch of triangles." Back then we were all like, "Maybe you should have higher order primitives or something." It's still triangles today mostly. You say, "These three vertices have a triangle, and these three, and these three, and these three." That tells you what the geometry is, and then you can have some additional properties like, "Oh--" If you want to vary the color over the surface, we have this thing called texture map.
Then each vertex can have an additional two coordinates which is like its positions in the 2D space of this image. That allows to stretch an image over it which looks too bad if you stretch it too much and stuff. You represent the geometry that way, and then, "How do we animate it?" Playing back these sets of coordinates is A, it's a huge amount of data. B, it has a lot of drawbacks, like it's ill-defined between frames. If you try to just straight forwardly interpolate the frames, you get these weird stretchy claymation looking guys all the time, which you don't usually want. We do this thing called skeletal animation, which is you start defining these things called bones.
For people with a math background, they're like a linear transformation that maps one set of coordinates in 3D space to another one, and it varies overtime. Then you store the position and orientation of the root of each bone, and that's something that you can interpolate overtime. Then the coordinates attach to that will rotate through space and stuff. Anyway, it's becoming a really long explanation, but that's just even to have the thing. The thing that used to be a sprite now is this thing, which is way more data and way more complicated to talk about. We haven't even talked about rendering this efficiently, which by the way is not that easy.
It doesn't sound like it would be hard, but it starts to get hard. Then if you wanted to say like, "Is my arm going to collide with this table?" You need to start thinking about things like how accurate does that collision need to be, for example. Is it good enough if I just represent around my hand with a relatively conservative sphere that captures all the volume. Then if it comes close to the table, if there's a tiny gap down there, can I see that or not? In a first-person game, you might see it if the gap is big, but in a third-person game where the camera's way back, you maybe don't care about that right.
Hand against the table is a weird example. It's not really something we would do in a game that much but character against a wall or something. Then you start saying, "Maybe I had these invisible boxes around all these bones that I was just talking about." It was one on my forearm and one on my wrist and one of my shoulder. A character might have 30 or 40 of these. They're animating all the time. Then I need to do some geometric intersection operation to intersect the arm with the table. Except that's not good enough because if my arm is moving fast, it might've gone through the table.
It might've been above the table on one frame and below the table on another frame. Then you have to do some time-interpolated collision operation or something, have some way to make sure that you don't skip that. Then the problem with all that is once you start doing math like this, it's hard to do that in a frame rate independent way. What if I'm running this thing on one platform and it's slow, and I'm getting like 20 frames per second, someone else is running something at 240 frames per second, which is not an uncommon number. That's actual gaming monitors these days are 240 FPS.
Does the thing that I programmed feel different or the same under those two conditions? The way that you might write a physics equation, for example, you're just doing a Newtonian, "Oh, this thing is moving around, and it's being affected by whatever," you might update the position based on the velocity, update the velocity based on the acceleration and then apply some friction like, "Oh, it's in air or water, so we're going to multiply its velocity down." Then you can just imagine. Those are relatively straightforward steps that anyone who even hasn't done games could probably imagine how to do pretty easily.
The problem is the behavior of that thing that you come up with will vary tremendously based on what your update rate is. Then you have to start having a strategy for that like, "Do we start trying to make the math more serious and more frame rate independent? Do we use a more serious numerical integrator?" Let's not go into that, but it's not simple. All of this is to do the thing that you used to be able to get in hardware like, "Oh, this sprite overlaps or not."
00:12:30 Bryan: How much are you able to use von Neumann computation for that versus, say, special purpose of hardware or special purpose of accelerators and how much of that? I assume that boundary has shifted over time.
00:12:42 Jonathan: [chuckles] It's complicated. In principle, as far as I know, the main acceleration that we might use today is a typical consumer PC or a game console has a pretty serious GPU, graphics processor on it, that probably has more transistors in the CPU. It's set up to do a different job. I don't really think of it as non-von Neumann. It just wants to have a lot more threads working than a typical CPU. Normally, if we were going to make a game, we don't really conceptualize things very differently if they're going to run on the GPU. We always could see how we could write them for the CPU, and how we can write them for the GPU. That might change more over time-
00:13:35 Bryan: Interesting.
00:13:36 Jonathan: -as the model continues to diverge. Usually, GPU programming is more about doing annoying stuff to satisfy the arbitrary constraints that are set forth for you involved in just talking to the GPU. I've got to feed it my data, and that has to be efficient. I have to get results back somehow, and that has to be efficient. There's this really weird-- CPU talking to GPU is slow. GPU talking back to CPU is slow. Once something goes to Vegas, it stays in Vegas. Then a lot of that is not necessarily hardware constraints. A lot of it is often software constraints because the APIs didn't take that seriously enough or whatever. Then also, this is the one part of what I do that's still changing substantially rapidly over time is GPUs keep improving in their capabilities. It's hard to say anything definitive.
00:14:40 Bryan: The fact that we do have special purpose computer-- To me, it's interesting because games have driven so much. Obviously, it drove us as kids, and I think it still drives kids in terms of it's their first exposure to computing. I think for most computer scientists, it's the first thing they write is a game at some level. I think that's still true. Jess, is that true for you?
00:15:03 Jess: You choose your own adventure games, [unintelligible 00:15:05] [chuckles]
00:15:06 Bryan: Right. Exactly. Then from the hardware perspective, we develop hardware too. I think that deep learning cannot alone support the GPGPU. The GPU needed that much broader use case, I would assume.
00:15:25 Jonathan: Again, it's not my job to analyze the business of these things. I feel what happened is that games launched GPUs and are the reason that we had GPUs. Like I said, games always want more computation. That's why there was this race because whoever made the faster GPU could show demonstrably better results. It wasn't just a number, it's like, "Look at the screen. This is better."
00:15:52 Bryan: This is better.
00:15:53 Jonathan: Yes. That happened for a number of years, but I feel now the deep learning people and the Bitcoin miners,-
00:16:01 Bryan: Certainly the Bitcoin miners.
00:16:02 Jonathan: -you put those two sets of people together, and they're probably a lot bigger than the game market. I feel like, but I don't know for sure.
00:16:12 Bryan: Yes. I don't know for sure either. Certainly, I think that we saw that the cryptocurrency mining was playing more of a role in that special purpose compute than anyone realized when it disappeared and all of a sudden a lot of the demand disappeared. That demand are correlated to the price of various cryptocurrencies. It's hard to know how the stuff is being used. It's sold. You don't actually know how people are necessarily using it.
00:16:42 Jonathan: I'm sure Nvidia knows.
00:16:45 Bryan: Sometimes I feel it's hard, honestly, especially if things are going well, it can be hard to know how these things are being used. You know who's buying them roughly, but you actually don't know sometimes how these things are being used and if they're being used efficiently. That's why it's always interesting when you're actually trying to connect what you can do in hardware and deliverable, as opposed to [unintelligible 00:17:10]
00:17:11 Jonathan: It's an interesting point. I just said, I'm sure Nvidia knows. Their most recent card was the Nvidia 20 ADTI. A classic thing about video game hardware is it's just ridiculous strings of numbers and letters. They makes no sense unless you've been following it. Their whole marketing for that was like, it has this capability to do onboard ray tracing, RTX was the thing. Honestly, it's a little too early to try and do ray-traced rendering and games. We do a different thing. Usually, you could maybe add it a little bit into scenes and get a little bit of a bonus, but it's a little early yet. The way this always works is you start and it's a little early and the next generation it's less early, and then eventually it's the thing.
We're on the leading edge of that, I think. The point is that they're marketing behind that card was this ray tracing thing, which deep learning people don't care about and Bitcoin miners don't care about. It's just a game thing. They must still think it's important.
00:18:14 Bryan: Oh, yes. I think that the consumer market drives more broad compute innovations than I think anyone really wants to talk about. I think it's a bit of an open question. The fact that we have been driven to more expensive processes at smaller and smaller feature sizes, how much of that has been driven by cellphones? How much of that has been driven by mobile? We need those broader markets, honestly, to drive it. That's why I think it's particularly interesting about, as someone who sits in that broader market, how you use these underlying compute resources. You use the Cell. That's such an interesting experiment that was performed.
00:19:01 Jonathan: Yes. The Cell processor, we should probably talk about--
00:19:04 Bryan: Absolutely.
00:19:05 Jonathan: There was this weird time, and again, this is my viewpoint of it as somebody who was not involved in the CPU world very directly but just peripherally working on software and stuff. We had this weird time where the way processors were-- the way that it looked like was the best way to increase performance for general-purpose processors was to give them deeper and deeper pipelines because they had to predict more. That obviously starts eating a lot of power. It's expensive and all this. People started looking at like, "What can we do if we take some of that [unintelligible 00:19:40] space that's being reserved for speculative execution and just try to do something more straightforward with it?"
The Cell was an attempt to say, "For what we're paying to do all this stuff, you could have a number of much faster, much tighter cores.
00:20:00 Bryan: Simpler cores.
00:20:01 Jonathan: Simpler, they'd have their own memory. They don't spend a lot of time waiting on memory, which is one of the reasons that you need speculative execution for.
00:20:09 Bryan: The [unintelligible 00:20:09]
00:20:10 Jonathan: We'll just do that. Then you'll write like little subprograms that you upload to these things and run them. DMA, it's not over a network. A project I did, did involve that. The theory was, you write a bunch of tight loops. They go to these things, you run them, you get the results back. Then you had a slower main CPU that was in order. It didn't do anything speculative. The job of which was to put these results together. They weren't the only people that did that.
00:20:45 Bryan: When was this? This was like, early 2000s, right? When is Cell?
00:20:50 Jonathan: The consumer console that had the Cell then was the PlayStation 3. Which I don't even want to remember exactly what years. When I was working on Cell was before it was actually out. The first time I was. That was in 2003. PS3 generation was probably like 2010 or something.
00:21:19 Bryan: We are now in the late stage of dementia of Dennard scaling. Dennard scaling is beginning to break down in 2003. We are still, because what, the power 5 gigahertz part is in there somewhere. It's basically 2005, I think is when that-- You're right in that point where people realizing that just accelerating clock does not make sense.
00:21:41 Jonathan: I remember talking to my friends about this in 2001 or 2000. On Intel CPUs it was starting to look like clock speeds were going to level off back then. Other CPS were probably pushing it further. They weren't the only people who had this thought. The Xbox 360, which was the competitor console for that generation, they didn't do that, but they said like, "Look, instead of one fancy out of order core, we're going to have three in order cores." You could have three cores. How could that possibly be bad? The answer is, Amdahl's law is why that's bad for both systems. Something that would happen on the Cell processor is just like, "First of all, it's actually a non-trivial problem to try to factor a program into these little tiny pieces that will go onto this coprocessor and run quickly."
00:22:38 Bryan: As an outsider looking in, I have to tell you that was my first impression of Cell. When I saw it, I was like, "Wow, this would be hard to program." Because you got to keep these units busy. Just the scheduling task has been thrown back on the programmer of, "I've got to have these little channel programs," for lack of a better word, "I've got to shunt out to these devices. I want to keep them busy. Then how do I figure out what's actually happening where or when?" It felt like it would need a lot of cognitive load.
00:23:09 Jonathan: Even to get to that problem is actually hard. Here's the thing about video games. There's different classes of problems. There are problems that are called embarrassingly parallel. Where it's just the data do not have much dependency on each other. That's a thing that you can factor out and put on the side. Games don't have that much that's embarrassingly parallel. Most of what we do has very heavy data dependencies-
00:23:36 Bryan: [crosstalk] on each other.
00:23:37 Jonathan: -on each other. Even just outside of CPU you try to run on, this has a lot of implications. When you go to computer school, and they tell you how to program. That you should factor your programs in certain ways, so that this module does not talk to this module. They don't know anything about each other. That doesn't make that much sense on a game. Because in some sense, games are about mixing things together and having the complexity come out on the screen in a delightful way. If you're generating sound effects, those sound effects should know what things look like. It should know what the surface looks like and how many dust particles are happening. A game is like a giant nexus of information coming together.
00:24:24 Bryan: [crosstalk]
00:24:25 Jonathan: Have fun factoring that onto your processor.
[laughter]
00:24:30 Bryan: I feel like with embarrassingly parallel problems. I think everyone assumes that someone else must have them. It's like the statelessness in Kubernetes, right, Jess. Where it's like, "All right. Everyone else has got these stateless problems. My problems have got this gnarly state that is interwoven into everything." I have to say, other than my early forays into game programming as a kid, I've always assumed that like, "I don't know, games must be embarrassingly parallel."
00:24:59 Jonathan: The reason GPUs are so successful is because the very tail end is embarrassingly parallel by the time you're done setting everything up. All this complicated thing, we've managed to factor it. At the very last step, where the pixels go on the screen, which involves actually quite a lot of math.
00:25:18 Bryan: That part.
00:25:18 Jonathan: Usually, not all the time, but usually the math for one pixel does not depend on the math of the neighboring pixel. Then you can go wide at the very end, but everything before that, it's not so easy.
00:25:32 Bryan: Not so easy. That is really interesting, and it's actually a lot harder then. When you got this interconnectedness, it's very hard to accelerate in hardware. [chuckles] All right. Cell was an attempt to-- Is that part of the reason that Cell struggled is because there was more interconnectedness than folks realized?
00:25:55 Jonathan: I think that was one reason. Also--
00:25:58 Bryan: It was like, Toshiba, and IBM, and Sony? Am I remembering that as the [crosstalk]
00:26:07 Jonathan: I believe those are the three companies. Actually, my first exposure to Cell was I was doing a project for IBM with some friends. We essentially wrote a whole game. IBM wanted to put these into servers because that's what they know how to do. Part of the reason I think that Cell floundered is all this research went into building this hardware in the theory that it was going to be dominant because these coprocessors were so fast, which makes sense. Nobody really had mapped out all the way to software of like, "What actually is this for?" They had weird stuff like, "Oh, you're going to have this in your refrigerator, and it's going to be awesome."
The Sony people-- See, I know people at Sony, so they'll get mad if I bring up embarrassing things in the past. They were saying things like, "When you buy a PlayStation 3, it'll talk to your refrigerator to get more processing power," or, "It'll call your friend's PlayStation down the street to get more processing power."
00:27:07 Jess: That's nuts.
00:27:08 Jonathan: They were actually saying that publicly, but also whether or not that's technically feasible at the hardware level, whatever, it doesn't make sense in terms of a game. In a game, you need to know how much processing power is available to decide what to do.
00:27:24 Bryan: "Is your fridge available now? Is it not available now?" Also, can you imagine like, "Yes, you beat me in that game because someone opened my fridge, and I lost the computational power and my frame rate slowed down."
00:27:35 Jonathan: Now, to be fair to Sony. Microsoft said equally dumb stuff. The next console generation. I'll just throw that in there.
00:27:43 Bryan: No company has got a monopoly on saying dumb stuff, for sure.
00:27:46 Jonathan: I think hardware people, we were in the mindset that like, "Look, we just know how to make this fast. Software people are lazy and stupid. We'll just get them to do the right thing when the hardware comes out. It will be great." Now, there is a little bit of truth to that. I don't want to like slag on hardware people. There's a certain way in which software people-
00:28:07 Bryan: [crosstalk] are definitely lazy.
00:28:09 Jonathan: -and are not that interested in knowing the details of the system underneath and all these things. Especially today, the difference between even knowing some basic high-level details about what you're running on and not is orders of magnitude difference in performance. This stuff really matters. I could understand being a hardware person and being just frustrating at that. The problem is, if that's going to be your plan, you have to actually know. You have to actually map it out from beginning to end what does this turn into when it's actual software. Nobody ever did that. You see today, nobody uses a Cell processor for anything. Nobody uses it to [unintelligible 00:28:47] processor for anything because it just didn't work out.
00:28:51 Bryan: The model didn't work, I think largely for software reasons. It was just a very hard model to program to, it seems like. You work at this project for IBM. Were you able to demonstrate any win?
00:29:09 Jonathan: The idea-- Let's see. Now, I don't know. This is a dead project from a long time ago, but some of it might be under NDA technically. The point was--
00:29:21 Bryan: If you're listening to this and you're getting uptight about Jonathan talking about the Cell, just relax. Because I think the Cell is an important experiment. I think learning from that experiment is also important.
00:29:38 Jonathan: No, it is super important. IBM was looking for like, "What can we do with servers that use this?" I was aimless at that time. I started a company with somebody. That didn't work out after several painful years. Then I'd done like independent consulting for a while. I was working on my own games on the side but not really, I was drifting around I just moved to New York, and I got hooked up with some people at IBM through some friends. I had this meeting with the guy from IBM and I was like, "Sure, I'll figure out what you can do with a server."
I had no idea prior to that so I went home and slept on it, and I came up with a plan. All this complicated physics stuff that I was mentioning earlier, let's actually take that one step further because then it will explain what this thing was. I talked about maybe your hand hitting a table or not. In a world full of stuff, it's actually more complicated than that. If you have a coffee cup on a box on the table and you bump the table, what happens? The things on it just-- You have these semi-free objects that are holding each other up and colliding with each other. If a box moves and my coffee cup tilts, but it's got coffee in the bottom so it doesn't tilt too far. All those physics computations, they're complicated in more than one way.
One is it's challenging to program those in an ideal environment. Then suppose you have a multiplayer game, and let's say it matters whether you're coffee spills or not because the point of the game is don't spill the coffee. The way you would do a distributed system in the face of internet latency and unreliable packet delivery and things like this is you would do what's called in games, client-side prediction, it goes under different names in different disciplines. Normally, we would make most of our physics just cosmetic. If I blow something up, it's got these chunks that come out and bounce on the ground and roll around, but they don't really affect gameplay.
What the server does is it sends to all the players, "Oh, this thing blew up." and we all generate our chunks and they bounce around. The problem is that the thing that blew up is going to be in a slightly different position for all of us because we're not synchronized.
00:31:53 Bryan: It doesn't matter. For this purpose, it doesn't matter that you and I are seeing slightly different things.
00:31:57 Jonathan: You get this butterfly effect where my chunk bounced off that wall and then that wall, and then hit the coffee cup and your chunk didn't. Game design was always about, "We'll start using this physics stuff but it won't matter." I said, "What if you make this cool game where the physics actually matters?" You have two problems. One is the synchronization problem. Because of the butterfly effect, you need to have a central authority over what's actually happening, and that would be the server. Then another thing that happens in multiplayer games all the time is people want to cheat. You need to have security over what's happening.
All of that means that if you had a server that was able to do physics really fast, you would enable a game that you simply cannot do with a client-server architecture with a weaker server in the traditional way. The goal was this thing is simulating physics all the time. We had this cool game design where you had giant robots walking around, multi, five-story high, and you could shoot joints of them. The arm would fall off or whatever. It was a small project, I did what we would call the game engine and the rendering, and my friend, Ackman, who later went to Oculus or he went to Valve and then to Oculus. I don't know if he's still there. He wrote a physics engine from scratch to do all this complicated stuff that I was talking about. Not only that, but do it on the Cell.
00:33:27 Bryan: On cell.
00:33:28 Jonathan: Not just one Cell because the IBM plan was you have two Cells and a blade or something, and you start slapping the blades in there. How do they talk to each other? The answer was 10 megabyte ethernet or something, 10 megabit, what was it? I don't remember.
00:33:49 Bryan: It was like a 100 megabit, maybe.
00:33:51 Jonathan: I think it was InfiniBand or something, it was slow. There was a 10-option and 100-option, and they didn't want to do the 100.
00:34:00 Bryan: [crosstalk] the InfiniBand. It's supposed to be InfiniBand.
00:34:03 Jonathan: I don't know. I wasn't paying that much attention to that.
00:34:05 Bryan: Right, but it sucked.
00:34:06 Jonathan: The point was because of what I was talking about before about in games everything affects everything else. Typically, what you would have to do is say, "We're at time T, we want to go to time T plus delta T," where delta T is like one-sixtieth of a second or something. We've got a world full of all these objects that are able to physically interact, and the job of this server is to just grind the iron and figure out all this physics.
00:34:33 Bryan: Right, and get back to me.
00:34:36 Jonathan: It's more physics than will happen on one Cell or even on one blade. You have to distribute the computation, every frame. Now, you're distributing it over a slow network. Fanning out the computations and saying, "Work on this," and then getting the results back. We actually worked it out of-- Even if there's no problems, even if we feed all the data optimally and manage to partition it optimally and all that, what is our speed limit just due to waiting for the bits to get over the wire and waiting for the results to come back? It was an appreciable portion of that frame time. We might not have been aiming for one-sixtieth of a second, I think, it was 10. When you need to do an entire job, 10 times a second, it's a just a different world than where a lot of people live in.
00:35:30 Bryan: Where the late results are useless. If you can't get back to me within a 100 milliseconds, whatever my frame is going to be, just forget it. We need to move onto the next frame.
00:35:45 Jonathan: We wrote our final report for IBM and our report was "This is not good hardware to do what you want to do actually." Trying to be helpful like, "Here's how you change it," whatever. They didn't like that.
[laughter]
Jonathan: If they're paying you to do a project, they want you to tell them how good their thing is. I've actually been in that scenario multiple times when I was a consultant, where I would tell people something is bad, and that's what they were hiring me for.
00:36:17 Bryan: I'm sorry, you were hired to describe how great this was, not to actually--
00:36:23 Jess: I think we've all been there, to be honest.
00:36:24 Bryan: We've all been there. I think, it all depends on what do you title your report too. I remember, we were talking to another technologist who was talking about he had an internal report that was not received well entitled Burn the Boats. I'm like, "Was it actually called--" "Yes. It's actually called Burn the Boats."
00:36:42 Jess: Your baby is ugly.
00:36:43 Bryan: Exactly, kill all management. "What's wrong with this report?" It's like, "I don't know."
00:36:49 Jonathan: This was not that bad. We were like, "Look, you need at least 10 times faster ethernet on this. Then even if you had that, it's still not that good of an idea because--" If you were to try to solve the problem, I just mentioned, we were waiting all this time just for the bits to go out and come back, you could start engineering that. Why don't we start compressing the data on the way out and back, and why don't we get super smart about what we transmit? Why don't we hold a lot of state on the individual blades?Maybe this one is authoritative over a portion of the world, and then if somebody crosses some invisible border, we move it to another one.
What happens if it's in the middle? Once you start doing that stuff-- We could have done some of that stuff, and it would have helped. First of all, you start driving complexity through the roof which in some sense, you were supposed to doing it much easier. That's indicative that something didn't turn out how you thought.
00:37:51 Bryan: It seems that part of the purpose of this was to make it, I assume, not just faster but easier to write games.
00:38:00 Jonathan: The history of games, it's weird because the history of games has been us getting more and more complicated and doing crazier stuff in order to do better stuff. There is a cost-benefit analysis that has to happen. How crazy are you asking me to be for what benefit? To be honest, it was my idea to do this kind of game. The idea of a physics-based game that can only happen with a big iron server is not that great of an idea. Maybe it would be if physics was better. Even today, in 2019, game physics are floaty and weird. Maybe, somehow if you got a really high quality experience, it would be a really good idea. It wasn't a super-good idea. Then how much were you paying to do this not-super-good idea.
[laughter]
00:38:55 Bryan: All right, we're going to take a quick break. Then we'll be back with more Jonathan Blow On the Metal.
[music]
00:39:03 Steve Tuck: On The Metal is brought to you by Oxide Computer Company. I got to tell you, the podcast has been more successful than I originally anticipated.
00:39:10 Bryan: That's great.
00:39:12 Steve: It's good news. Folks are liking the content. There has been some negative feedback though.
00:39:17 Bryan: What, for the podcast? The podcast is great, these interviews are amazing.
00:39:20 Steve: The podcast themselves, folks are liking. I've gotten a couple of emails, specifically calling out the repetitive ad content. It's driving them crazy.
00:39:27 Bryan: We only recorded three ad rolls. I know, we've got a lot of ad breaks.
00:39:31 Steve: They were reminding me an email about the fact that there's only been three ad rolls that they've had to hear again and again and again.
00:39:36 Bryan: Oh my God, we're so sorry. It's a great podcast. We don't want to ruin it with repetitive ad rolls.
00:39:40 Steve: I think, it's something we should keep an eye on.
00:39:42 Bryan: In meantime, we should just tell people to go to oxide.computer.
00:39:45 Steve: Yes. that's all we need to do,
00:39:46 Bryan: Sign up for their mailing list, and then we'll shut up. Hey, if you've got any feedback on the ads, definitely send that to us.
00:39:53 Steve: Sure, we're getting it.
00:39:55 Bryan: All right, sounds good, back to the show. We're back with Jonathan Blow.
00:40:03 Jonathan: I can say one thing before they question her. I did later. I did two things on Cell. That was one of them. Then the other one was a lot easier and more simple because there are some embarrassingly parallel problems in game still. Again, because we managed to factor-- One of them is particle systems. I mentioned explosions before. You might have chunks of thing in explosion, but you'll also have just lots of little dust particles and smoke and whatever. The way those tend to happen in games is with a system that just does a bunch of little billboards that are animated over time. They may have ways of interacting with the environment, but it's very constrained. It's like its own thing. Whenever you have something that's its own thing, you can optimize that and crank on it.
00:40:50 Bryan: I think you're making an interesting point earlier that when you have something that it's his own thing, it's not necessarily that core to gameplay because part of the game is that interconnectedness, it's what makes the game interesting.
00:41:00 Jonathan: Yes. However, every once in a while, we discover things that are exceptions to that. Particles are great because you just have a lot of them and they really help things look cool. You just found that and--
00:41:12 Bryan: How much of that is "Wow, this game is a lot more fun," versus, "This certainly looks better"?
00:41:20 Jonathan: It's more the second one. Actually, even in the earlier days, those two were not as clearly differentiated. Now, graphics are pretty good. Back then, no.
00:41:29 Bryan: I watch the games my kids play, and they basically play the logical equivalent of Atari 2600 games. Do you know what I mean? The games that really captivate them are the games that are super simple but have great gameplay. No particles. My kids have a low bar for their own entertainment, which is something I've always believed.
00:41:57 Jonathan: There's weird generational stuff that happened. Around the time of Minecraft, which may be one of the games that they play, I don't know. Minecraft came out. It was this super low-res, super chunky, very pixely, both 3D and 2D. Everybody looks at that, who is a professional game developer and says, "Oh, yucky graphics," or whatever. Kids don't know that. They don't know that we worked so hard to get away from the Atari 2600. They just think, "Oh, that's a retro style," or something. It didn't have the negative association that it would have for somebody who spends all day trying to make things look nice.
00:42:35 Bryan: It's just fun. I'm sorry about my kid. I don't know any better. It's just fun.
00:42:42 Jonathan: Minecraft is actually a reasonable game, though. I don't know what gams you're talking about.
00:42:45 Bryan: I think this is more the games on their phone. They play basically these very simple arcade games. They're definitely very precise in terms of what they-- They're very captivating for them. They play levels that their friends make and stuff. It's interesting in terms of the relative simplicity of this stuff. It's amazing to me also how much the kids still love these basic puzzle games. They're the--
00:43:13 Jonathan: Tetris [crosstalk]
00:43:14 Bryan: Yes, exactly. It's like the logical descendants of Tetris are still really captivating. Another thing you need to emphasize also that the gameplay is really important and that it's easy especially with an abundance of hardware to do things that are cool, but do they actually result in a better game? For some, I'm sure. It's like the more immersive the experience, the better the game for some people. Having dust come up and a sound effect associated with that is going to make it more immersive.
00:43:47 Jonathan: Yes, there's definitely different ideas of what a game is. Somebody who plays Red Dead Redemption 2, which is one of these games that's trying to be very high graphical fidelity and make a mood out of that and all this, probably isn't going to be playing the games that you're talking about. That's maybe a good sign. It means that that as an industry, we have a lot of different things that we could do. Talk to different people. We ran over your question.
00:44:14 Jess: I was going to go back to the butterfly effect because one question that I got in an interview for a job and also one of my friends worked on Halo. I hear a lot about it is the distributed systems problem of like multiplayer games. Say, I shoot Bryan--
00:44:29 Bryan: Hey, that's your example? That's--
00:44:35 Jonathan: [unintelligible 00:44:32]
00:44:35 Bryan: Can't you shoot a duck? Why do you need to shoot Bryan?
00:44:37 Jess: Because it's Halo. Bryan moves or at least thinks that he moves out of the way. On my screen, it looks like I hit him. It's like solving that problem seems to be-- At least from people that I've heard. Solving that problem in a way that people can't cheat, which is also a problem that Halo had for a long time, it seems to be not logic-based. It's more like filling no holes. I was wondering your take, honestly,
00:45:04 Jonathan: This is a complicated subject behind which there is much history. The fundamental problem again there is network latency. Even if everybody's getting perfect information all the time, which doesn't actually happen. We're going to simplify and say that everybody's getting all the information about what happens when. It's just they're getting it with different amounts of time because I have a 10 ping to a server and my friend has 110 ping. That's a tenth of a second difference. It sounds like a small amount of time, but it's actually quite large at the speeds that people move in games. In a tenth of a second, you can be a third of the way over on the screen.
You can be completely non-intersecting with where your body was before that tenth of a second. These times spans matter actually a great deal. What do you do about that? One reason why this it's so complicated is because the answer to this question or what you should be reasonably thinking about has changed a lot over time. My first professional game actually, I started in the late '90s, 1996. We were working really hard to do this live client-server update stuff over 9,600 baud modems which was good. Those were fast modems back then, 9,600 baud. Again, we started having difficulties like how much time does it just take the bytes to go over the modem? That was an appreciative percentage of the total latency, actually.
00:46:37 Bryan: You were trying to do a [unintelligible 00:46:38] have first-person shooter?
00:46:40 Jonathan: Yes. It was a sci-fi hover tank game. A lot of the weapons were indirect. It would be I fire a missile at this guy, which is one way of working around this problem.
00:46:50 ?Steve: It could take longer.
00:46:52 Jonathan: Because The missiles simulated on the server and then the server decides what [crosstalk] and you eliminate this. The problem is in these first-person shooter games people move pretty fast. The server can't be authoritative over certain things. For example, if I move the mouse, I tell the server how much I moved the mouse, and then the server decides how much I turned, and then it tells me how much I turned, and then I go that much. Even if the latency numbers sound really small to you, it's going to feel really bad.
00:47:28 Bryan: Because you are now well within the domain of human perception.
00:47:32 Jonathan: Not even just perception. I forget the name of this. There's a way that humans used tools where you consider it part of your body almost. If you've got a hammer in your hand, you're not thinking that hard about the fact that you're using a hammer or you're holding a thing that's hitting a thing. You're like, "Oh, I'm just whacking this thing." There's some mental fusion that happens. Games take advantage of that, actually. If you're playing a keyboard and mouse game. Destiny is usually gamepad, but mouse is a little bit harder. I may use that one. Somebody who's played these games a little bit doesn't think about the fact that they're controlling it. They're just moving their hand. It's instinctual. You kill the ability for that loop to happen.
00:48:18 Bryan: It does not take much latency, I imagine.
00:48:19 Jonathan: Yes, not much. Also variable amounts of latency. Because your body, [crosstalk] can adjust to a fixed amount of latency. It's not good but you can. When it's going up and down, you're like, "This feels terrible. It feels very frustrating." What do you do? What people started doing, there were some famous presentations at conferences in maybe late '90s, early 2000s, I forget, evangelizing different ways of solving this problem that I didn't personally like. There's at least two different problems. One is this problem of variable latency. People are seeing the world state with different-- How can I explain all this?
00:49:10 Bryan: There's a skew in the way that they're seeing the world.
00:49:13 Jonathan: Yes. There's the fact that where I see things is by definition not where the server thinks they are. That's one thing. Then you have a second thing that's if two people take an action at about the same time and it takes a certain amount of time to travel to the server, and they're conflicting actions like who wins? That's a whole other thing. Usually, we punt more on that second one than the first one. Anyway, if we go back to the gun example, let's say you're standing there, and then you duck behind a corner in 100 milliseconds, but I shoot you before I see you duck behind the corner.
Even take the corner out of it. Let's just say you're in the open space. What a lot of systems did that people started building was we look at when the shoot message comes in. We'll go back in time to when-
00:50:08 Bryan: It was actually fired.
00:50:09 Jonathan: -what we think your latency was, which by the way may not be a correct number especially if it's fluctuating. We go back in time that much, and see if it looks like you were hittable from where I am, not by exactly where I was pointing because, again, that won't totally make sense but in general. Then we'll count you as hit or not hit. What that looks like from your side is like we're in this intense gunfight. We get some shots off, and you duck around the corner, and maybe I hit you around the corner because you weren't around the corner before. Again, this is where it gets complicated. Maybe at the time when the server needs to make the decision, you weren't around the corner yet according to it.
The server could decide, "Oh, you're behind the corner now, but you weren't before. We're going to give you the benefit of the doubt." There's all sorts of weird heuristics. The fact that there's all sorts of weird heuristics means that by definition not everything is going to feel good. Something is going to go wrong. It's at its core and not that solvable of a problem. Today, internet is a lot better usually. You have some of these things like this thing Google is doing right now, the Stadia thing. Which is like look, "The entire game just runs on a server, and we just send you the pixels." It's not how I would do it, let's put it that way.
00:51:36 Bryan: The Stadia seems to have-- It seems to be rather controversial.
00:51:43 Jonathan: We can just use that to highlight the fact that the assumptions there have to be very different. They have to be like, "Oh latency is going to be consistently very small." What I always think about is this client side prediction along with server side heuristics about managing these events. I always, as a player, want to put a cap on that.
I want to be able to say, "Look I don't want to play with anybody with a ping more than 50 milliseconds." I just wish a game would let me do that. Put that in the match making or something. It's fine to have this kind of a thing, but let me control it or something. Nobody's done that, so maybe I have to do that at some point.
00:52:27 Bryan: This is a hard problem because you are up against real physical limitations. Think about a 50-millisecond latency. We can put physical constraints about how close that person's going to be to you. That's person's not going to be in New York while you're in California. That has human perception consequences. There are real physical consequences for the game. Take the Stadia thing. First of all, actually, this correction of the past which our brains do do. Because your brain will correct for a time that it didn't perceive.
You'll notice this when your eye falls on a clock with a second hand, and the second hand seems to be stopped, and then it starts moving again. That's because your brain has corrected for the time that your eye was in motion. Our brains do the same thing too. We don't like it actually. Did you not like that approach?
00:53:44 Jonathan: Here's the thing. It comes down to why do you play games to begin with. Different kinds of games have different audiences, they have different reasons for why they play games. There's this weird, what I would say, conflict in the game design community where there are incentives to pull different directions. A shooter game is in theory about being better or worse at being able to do the shooty stuff. It's a competitive thing. It's like, "If I win, I'm probably better than you," in the same way that if sports games win, whatever, one of them is better. Playing that game is ostensively, to the people who are interested in it, about building your skills at the game and working on it in some sense and getting better.
There are some shooter games that are way more serious. For example there's a game called Counter-Strike on the PC. They did console versions, but it's mostly PC game where it gets really serious. There are world tournaments of video games, sports teams playing each other at this game all the time. It's a very fast and vicious game. The skill level is very, very, very high. What a lot of people want to play this shooter game for is for a more casual version of that. If you're a company and you want to sell a thing to the most people, it's tempting-- I think this is true as well. A certain number of people are playing it for a different reason.
They want to be the fantasy of the cool army guy who kicks ass. Maybe they don't care about being good at it. If you include those people, you get a bigger audience. I'm not sure which group is actually bigger. Most people will tell you that that latter group was bigger, but I think that's wrong. I think people like being competent actually mostly. I think that's undervalued. The point is you'll make different design decisions depending on which game you think you're making. This design decision about like, "Let's give people the most smooth feeling, the most comfortable experience at the cost of unfairness essentially." Maybe you got out of the way in time, and you still got hit.
That turns off people who are interested in competence to a certain degree because they get really good at the game. The more good you are at it-
00:56:25 Bryan: The more injustice.
00:56:27 Jonathon: Yes. First of all, the more you see these things. A new player might not notice that this is really happening. After a while you're like, "No, that was wrong." Also, the more you feel you're being disrespected by the game. It's like, "Look I'm putting you in this effort, and the freaking game is not even right." It's just angering. I would feel that the right decision to make would be more in support of competence, whatever that means. I hope we go that way. We haven't gone that way historically. Like I said, we have different match making tranches or whatever according to connection quality.
If you have not that good connection and you want to be good at the game, how serious do you take this? Do you take it seriously enough to make sure that your Comcast connection isn't terrible or whatever or don't you? If you don't, that's fine, but you just can't play in the top thing. I would prefer that as opposed to just pretending like you're having a fair and reasonable match when you can shoot somebody half a second ago. That doesn't make sense.
00:57:43 Bryan: I think getting to why games-- because there are a lot of different games out there, but I feel that the ones that are popular with the broadest possible folks are not necessarily ones where the industry focuses. Is that a fair assessment? It feels like that the industry focuses on a narrow tranche for economic reasons maybe. God knows my kids have never paid for a game.
00:58:14 Jonathan: There's almost not really one video game industry now. The traditional one, which is the one that I live in, and all these stuff I was talking about about physics and whatever is all from that one. Then there's the IOS game industry. Hopefully, your kids are not playing the most exploitative games. A lot of these are-- I think of them as just pretending to be games in order to have a micro transaction button or something or to show ads. Those are very different things because they're all about exploiting people's psychology in, I would say, unethical ways.
Really they're not usually very interesting as games because they're only trying to be a game in as much as is necessary to get people to spend time in front of it and to engage the worst compulsions that they have. I actually have very little respect for that whole industry. I don't know if this includes the games you're talking about here.
00:59:14 ?Steve: Are you talking about the modern iterations of the classic SimCity, like FarmVille. SimCity was great, and it was productive and healthy but some of the newer dumb down versions of it, people sit in front of a screen just clicking all day.
00:59:30 Jonathan: It's a weird thing. SimCity and FarmVille from a 30,000-foot view don't look that different. It's like you're controlling this speciously laid out structure and building it up. SimCity is a creative activity that involves thoughtfulness and problem solving and skill. FarmVille is just about getting you to sit in front of the screen for as long as possible. They're two different things at a basic level, and I dont like that. 
Again this makes people in my industry mad when I just say it that bluntly, because it's like, "Look--" [chuckles] I mean, I say it different ways at different times, but like, "If you don't respect the player, if you're not trying to actually give them something, if you're purely entering this from a perspective of trying to take something from people and give them as little as possible." I mean, on the one sense, that's the optimization of capitalism, but in the other sense, that's very socially-negative, and we recognize that as a society. In fact, in other industries, we ban things, sometimes with quite harsh legal penalties when they're seen as socially negative enough.
I'm not calling for banning those games right here, but I certainly don't respect the people who work on them, put it that way. That's how I feel about it.
01:00:50 Bryan: I also feel that, has their time come and gone to a certain degree? I feel like that there was a Farmville moment. I mean, it feels like that people are more aware of the exploitive nature of things.
01:01:07 ?Speaker: It feels like they're just prevalent. There's just different iterations of them. Whether they are like a particular media star that has their own game now where you can go through a house and you can buy things if you build up enough points or pay for enough points.
01:01:21 Jonathan: Yes. Like with dot-com booms and busts, or technology booms and busts. There's been several waves of this. There was casual games on the PC. Then Facebook happened. Then somehow, there was all these games on Facebook. Which is where Farmville I think came from.
01:01:36 Bryan: Right.
01:01:37 Jonathan: Then the smartphones happened. Then you had the first wave of this stuff on the smartphones, and maybe now we're in the second or even third wave of sets of games that are all doing the same thing, that's like different from what prior generations of them did. They do come and go like waves, but new waves keep showing up. The ocean doesn't run out of waves.
01:02:01 Bryan: [chuckles] Right. Do you have a favorite game that you've played? Like a game that helped inform or drive your career in the game space?
01:02:10 Jonathan: There are a number of them, and they're all-- It's an eclectic group. When I was a kid on my Commodore 64, I liked the text adventures, like the Infocom Text Adventures. My favorite one was a game called Trinity by Brian Moriarty, which was probably the most like literature, I would say, or the most that hit me in the right spot. It was sort of a science fiction premise where like World War III happens, and you managed to escape in this weird, extra dimensional way. Then you're trying to prevent it from happening by going to all these historic times when moments in the development of the atomic bomb were happening, for example. It's a little bit of a spoiler, but the end game happens--
01:02:52 Bryan: This was an Infocom game?
01:02:53 Jonathan: Yes.
01:02:54 Bryan: Oh, nice.
01:02:55 Jonathan: The end game happens at the Trinity test site, it's historically recreated and stuff.
01:03:03 Bryan: The InfoCom games are available. I mean, you--
01:03:05 Jess: Yes. I'm going to find it after this. I was like, "I've made a mental note, I'm going to go."
01:03:09 Bryan: That sounds fun.
01:03:11 Jonathan: Yes. There's these sets, I think they're still called The Lost Treasures of Infocom. [crosstalk] I think you could buy it off Amazon or something, and they'll send you a box with all the maps and cool. Those games always had little physical objects.
01:03:22 Bryan: Right. Their [unintelligible 01:03:23] are so great.
01:03:25 Jonathan: I think you also could get it on iOS. I wouldn't recommend that because I think on a touch screen is terrible. I think in those cases, they have screenshots of it, or I don't know, of the little bubbles. Anyway, so that is very different from what I do today, but it affected me in a relatively deep way in terms of the way that I think about a game. Sometimes the way a creator does things, you feel that and you keep that as opposed to the surface manifestations of whatever it is, the thing that they made.
01:03:52 Bryan: Did you, cause I was much older when I realized how they actually implemented that stuff, in terms of like, they had their own virtual machine. Infocom was a super interesting company.
01:04:01 Jonathan: It was a little wacky. Yes. It's weird. I think of them as such a major, major part of my childhood and stuff, but that company wasn't even around for very long, it was like-- I want to say like four years, it might not have even been that long. [crosstalk] Things happened fast back then.
01:04:19 Jonathan: Yes. It felt so seminal. I don't know.
01:04:22 Jonathan: Maybe that four years is incorrect. Fact check me later, but, yes. In college, when I should've been studying computer science, I played a number of video games. I played [unintelligible 01:04:34], which were the multiplayer text adventures back then. My favorite game was a game called Netrek, which was actually made by students there, which was a client server. I would describe it as like playing football with star Trek ships, so you had different classes of ships and you were trying to fly around, and it updated very blanketly at 10 frames-per-second on Sun 3/60 workstation [crosstalk] or Apollo workstations. I don't know if you know those.
01:05:01 Bryan: I do know definitely Apollo. Because the Apollo lab had just been replaced by the Sun lab when I showed up at university. They had just gotten rid of the Apollos, which, yes. That's your first real exposure to networked games too?
01:05:18 Jonathan: Yes.
01:05:18 Bryan: Because we did not have-- When you and I were growing up-- I mean, the BBSs were not on a 2,400 baud modem. It was not-- I didn't play any networked game.
01:05:27 Jonathan: There was a weird stuff that was a little bit gamish, but it was very asynchronous. I'll do a move and then log out, and you'll do a move tomorrow. I never really played those. They weren't very engaging.
01:05:39 Bryan: You discovered networked games at school?
01:05:41 Jonathan: Yes. Then, my first company after school, I mean, I worked a real-- Okay. After school, I did a really boring enterprise software company for six months. No offense to the people I know from that time, but it wasn't my thing. Then I went to-- I got a contract at SGI, which was still a thing back then. I ported this relatively famous game, Doom to the set-top box system that they had. That was my first top box professional--
01:06:10 Bryan: Is this for the Orlando thing?
01:06:11 Jonathan: Yes.
01:06:12 Bryan: Wow. There we go.
01:06:13 Jonathan: Yes.
01:06:14 Bryan: That set-top box is amazing.
01:06:17 Jonathan: I don't know if I would say amazing without quotes around it.
01:06:19 Bryan: It's amazing. Oh, it's amazing.
01:06:23 Jonathan: How do you know about this?
01:06:24 Bryan: I felt like this was something that was well-known at the time.
01:06:28 Jonathan: Because it was hardly deployed. It was deployed a little bit in Florida and a little bit in Japan, as far as I know.
01:06:33 Bryan: If I recall, it was classic SGI in that it was technically very interesting at a price point that was insane.
01:06:42 Jonathan: I don't remember of what--
01:06:43 Bryan: I think that the box is going to be like $10,000 a box. It's like, "Well, no one's going to buy those." I mean, that's-- Because they actually deployed them in- it was in Orlando, right that they-
01:06:54 Jonathan: I believe so.
01:06:55 Bryan: Yes. I think I felt like it was a famous folly by the time I arrived in Silicon Valley in 1996.
01:07:04 Jonathan: So, toward the end of this project, like one or two months before my contract was over, all the relatively senior people all left to go to Netscape, because Netscape was poaching from everywhere. That really put-- it was like, "Oh my God, we were having a hard time on this project, and now everybody quit."
01:07:20 Bryan: Everybody just left.
01:07:21 Jonathan: Yes, but so, same problems seem to keep coming up. Doom, it was made to run on PCs with local disc, and these set-top boxes didn't have local disk. They talked over Ethernet to a central server to get files. That's fine if you want to read big files, but Doom, it's got a thing, it was called a WAD file for Doom, but it's basically like a zip file or a package where you put a bunch of little pieces of data into one file.
For a given level, it would look up an index of like, "Okay, which graphics do I need? Which sounds do I need?" It would seek back and forth around this file, and of course, the API for this set-top box system didn't have an efficient way to do that. It was like, if you did a lot of small reads, each one was a round trip to the server and back and who knows? I actually shipped-- I mean, to the extent that this thing shipped, I wrote a server that you would coalesce all your reads and send it to that thing. It would do all the reads and package them and send it back to you, which I'm really-- I mean, my ideas of what was okay to ship in terms of software quality back then are very different from where they are today.
Just my level of experience is very different and stuff. I'm scared of whatever it is that I wrote to do that. I mean, that was officially-- It was a really weird thing because, at first, I was talking to other people in the group and I was like, "Look, we need to do this. It's just too slow. There's nothing I can do on the client side to make this faster with the API that you've given me." They were like, "It was a staunch no". Then eventually, it was like, "Oh, fine, but give us your server, we'll install it." I don't know. It was weird.
01:09:07 Bryan: What was the graphics acceleration on the hardware on that? Because I do feel that you can trace the Nvidia origin story potentially through this project. The Nvidia folks all came from SGI. It was all the Odyssey folks at SGI that quit and went to--
01:09:26 Jonathan: Yes. I'm not sure about that. I assume it had a graphics accelerator in it because it was SGI. I remember it could do like alpha blending and stuff. There was definitely a thing where there was something at least doing fast compositing and probably some other graphics pipeline stuff. The thing is my port of Doom didn't use any of that stuff because Doom was made for the systems that do not have that, pixel at a time. I was just making that work, which it was just like, fill out the image and then call the thing that presents that image. It's not actually particularly low level.
01:10:10 Bryan: Interesting. Actually, I ported Doom to Qnex, which is a real-time operating system at about the same time.
01:10:18 Jonathan: You know what I'm talking about?
01:10:19 Bryan: Definitely. Yes, the WAD file definitely brings back memories.
01:10:22 Jonathan: Yes, it wasn't that hard of a thing to port. [crosstalk] Which was great.
01:10:24 Bryan: It was not, actually. It was pretty cool. Sort of the 286, it was actually quite a bit. Wolfenstein was the one that was a-- I'm sure you had the same, again, because we're roughly the same vintage. That was just eye-popping to have.
01:10:42 Jonathan: Yes.
01:10:43 Bryan: All of a sudden, you're running on a 286 or 3D6X, or whatever it was, and all of a sudden, you had what felt like a 3D game.
01:10:53 Jonathan: It's mostly 3D.
01:10:54 Bryan: It's mostly 3D, right?
01:10:55 Jonathan: Kind of. It came in steps. Wolfenstein is doing this, what we call 2.5D where it was essentially a 2D map of the world, then walls have heights or whatever, and you sort of fake it. In Wolfenstein, all the walls were, essentially, on graph paper. They were all orthogonal to each other and that means certain things are mathematically nice. You don't have to think that hard if you're trying to figure out how to render it.
It's weird, earlier games had much lower performance, pseudo-3D stuff. If you played the Ultimate Games or something, if you're in the dungeon and you hit forward and it sort of redraws this dungeon thing that is just some white walls with a couple of squares on it or whatever. You definitely could connect it to things that were earlier, but at the same time, it was a qualitative jump in what was being done. Doom was even more. Doom was like not gritted. No, it was like freeform.
01:11:57 Bryan: We're going to take another quick break. I want to come back and I want to talk some more Doom here when we're back with more Jonathan Blow On The Metal.
[music]
01:12:08 Steve: On The Metal is brought to you by the Oxide Computer Company. Thought we had a bit of time to deal with this, but it sounds like the listeners are pretty restless.
01:12:16 Bryan: Oh-oh. Is this about the ads?
01:12:18 Steve: Yes. The inbox is full.
01:12:20 Bryan: Oh, boy.
01:12:20 Steve: They also have begun recording their own ads and sending them to us requesting mercy from the repetitive ads that we've been subjecting them to.
01:12:28 Bryan: Wait a minute, they're in such pain over the ads that they're sending us ads for Oxide?
01:12:31 Steve: Yes. I got one out. Have a listen. This is from listener, Paul Gwaz.
01:12:35 Paul Gwaz: We're getting really, really, really tired of listening to the same oxide.computer ads every week, talking about, How The Oxide Computer Company is going to make your own premises infrastructure faster, more efficient, more secure, and just all-around less painful. So much so in fact that I wrote and recorded this ad. Head on over to oxide.computer to learn more and join the mailing list.
01:12:58 Bryan: I think we should just do what Paul said.
01:13:00 Steve: Yes. Let's just follow his instructions.
01:13:01 Bryan: Let's get back to the show. All right, we're back. Jonathan, you just ported Doom to SGI's doomed set-top box.
01:13:12 Jonathan: Yes. Actually, I assume it never went anywhere, but I don't actually know.
01:13:17 Bryan: I think the price point was debilitating. Again, it was viewed as a folly, I think. It was a Silicon Valley company trying to enter consumer electronics in a way that backfired. It was kind of how it was pursued, but do you think that some of that-- Although SGI was kind of coming apart at the seams at that point. They had a CFO with a coke problem among other things?
[01:13:39] Jonathan: Yes, okay. It doesn't sound good.
01:13:42 Bryan: No, it was bad.
01:13:43 Jonathan: Don't do that in your company.
01:13:45 Bryan: No, no. We will not be doing that. We will not be doing that. SGI had-- It was a hugely innovative company, but it was nuts.
01:13:55 Jonathan: Yes, I don't know what happened, because the world became so much about graphics, and they missed that. It's like they were in the earlier age of graphics, then they missed the transition.
01:14:07 Bryan: Yes, they didn't know what they wanted to be. Whether they wanted to be an enterprise computing company or a graphics company. [unintelligible 01:14:13] It was Silicon Graphics, and they changed their name to SGI.
01:14:16 Jonathan: Right. Yes.
01:14:17 Bryan: Which is one of these corporate moves. You're just like, I have head and hands. This is like when SUN changed the ticker symbol from SUNW to Java. You're like, Oh, God. No. Exactly. Thank you for just embarrassing every employee. Every employee just has their head in their hands, like Oh, my God. I think that, as I recall, it was a bunch of the Nvidia folks were all ex SGI.
01:14:44 Jonathan: That's quite plausible.
01:14:44 Bryan: I'd want to go check that. What did you do after SGI?
01:14:51 Jonathan: I started a company with a friend here, actually. Our first office was in Oakland, Downtown. There was this mall like at 12th Street, we had a little thing there.
01:15:02 Bryan: This is in the early 2000s, post-dot com bust or?
01:15:05 Jonathan: No, this was '96.
01:15:08 Bryan: Oh, wow. Okay.
01:15:09 Jonathan: Yes, this is pre dot-com bust. This company lasted till like 2000-2001. We saw the whole dot-com thing happening, I was just like, I'm not doing that. I'm doing my thing. It was really difficult. Well, first of all, we didn't really know anything about video games. We had no experience, except I programmed games, I played them and stuff but, it would it would have helped to have somebody who had done things in the industry before as opposed to us, which were just like, Hey, let's start a game company. Okay, how hard could it be. But also it was, I'm convinced, the hardest time in history to start a video game company, like almost to the month, because, previously games had been 2D.
So, beginning of 96 was when Quake Test came out when we were starting our company, which was like, basically, fully running quake but without all the levels and stuff. They were just doing a multiplayer beta to make sure all that worked. So, Quake was the first real- it wasn't actually the first fully 3D game, but it was the first that ran at high frame rates where actiony things happened, and that just changed the whole game industry, and so everybody had to do that. The problem is nobody really knew how to do that, at many levels. So first of all, like we were saying, no graphics accelerators.
You had to draw every pixel on the screen, you had to do that really fast, and just a significant amount of math was required. All this, the whole geometry situation was not quite as complicated as what I said at the beginning, but almost getting there. Just computers were still kind of slow, and so, you really had to sweat. We were working on 486's in the beginning, we were working on 486's, and we were hoping to ship for 386s also.
01:17:12 Bryan: I mean, think of this, this is a 66 megahertz clock-rate on a 46.
01:17:18 Jonathan: Sometimes it was that high.
01:17:19 Bryan: Right, exactly. Lower. I mean, you think about like the amount-- that is running on a RISC five today, in terms of the what you were doing. How little the horse power is.
01:17:33 Jonathan: I don't know how to compare it honestly, [crosstalk] today, but also, the thing that you do in games is, you're trying to be ambitious. You're not trying to do the same thing that people already did, you're trying to push ahead. We were trying to do like an open world where you could drive your little hovering tank around all these mountains and stuff, and part of the secret of Quake was it was indoors and very constrained visibly, so you didn't spend a lot of CPU to figure out what to render, there was that. There was a great deal to learn but, here's the great thing about this time historically, is that the guys who worked on Quake, which was John Carmack, who I guess he was CTO at Oculus recently, and now just quit to go do AI on his own; and Mike Abrash, who's a relatively well regarded, famous person as well.
Were working really hard for a year and a half to figure out how to make this game possible. I guess the whole development was like a year and nine months or something. Again, fact check those, but they then went to these conferences, for example, the Game Developers Conference in San Francisco and said, Here's exactly how we did this. Everybody else in the industry who we're extensively competing with, Here is what we did to get the geometry on the screen, and the most magical thing was the texture mapping loop that would go from pixel to pixel and they said, Here's our assembly.
Like anybody obviously could disassemble it, but it was really weird because the inner loop that wrote each pixel. Like [unintelligible 01:19:02] figured out weird side effects of some of the x86 instructions that weren't exactly the intended purpose, but when you strung them together, you could get some work that you wanted to happen to happen. I spent a lot of time trying to do variants of that. They had this six cycle thing, but of course, you want to add features and stuff. You try to add cycles to your texture mapper, but not too many, and because you didn't have that many addressable registers back then. I'm sitting there programming in assembly and like, Okay, we're going to use the base pointer as like a general register because we don't-- Then that makes it really fun to debug.
01:19:37 Bryan: There you go. Right, exactly the classic reuse of the frame pointer. Oh my God, there's a special place in hell for people who would reuse the frame pointer. I am looking forward to the room in hell just like, Wait a minute, what are you doing here? Then you finally realize like, Wait a minute, we all reused the frame pointer. That's why we're all-- Yes, I know. You had to, you do have to, but God, it makes a brutal little bug.
01:20:00 Jonathan: That's what I was doing for a few years, and just, we didn't have business savvy. Also, it was a weird time. We ended up signing our game with these companies that were going to try to be like cable TV channels, but for the emerging internet. The idea was they would provide low latency connections over your modem. We signed with this company called Total Entertainment Network that was based in San Francisco. We made some money off that contract, and that kept us alive at subsistence level for some amount of time. Eventually, that whole market just didn't happen. It didn't end up that people were paying subscription fees for good modem gaming.
01:20:38 Bryan: Right, right.
01:20:39 Jonathan: What happened instead is just the more open internet happened. If we had done something where it was like, we're selling our game directly over the internet, we might've actually succeeded. Even though that was crazy. The idea of processing a credit card on the internet in 1996, hardly anybody did that.
01:20:59 Bryan: Right, and I just think about it being a tough time, because it's like post-internet, but pre-internet at the same time. It's like everyone knows the internet is here and no one has it yet.
01:21:07 Jonathan: Yes.
01:21:08 Bryan: It was all dial-up, it was super slow. This is what-- You remember boo.com?
01:21:15 Jonathan: That's ringing a bell, but I don't remember.
01:21:16 Bryan: They were a retailer, or they got to be a streetwear retailer that had a super complicated flash retail site when everyone only had 57K at best. It was like, you had to wait for 15 minutes for the site to load. It's like, "Well, goodbye." The retailer, same thing. It's as if you're in exactly the wrong time.
01:21:38 Jonathan: I worked hard for years and was very sad a lot of the time. It's a large part of where I learned how to program. I went to college at Berkeley. I programmed a lot at home in high school and grade school on home computers, so I kind of got that. Then I went to computer science school and it was like, "Oh, so there's actual formalisms behind some of these things." Which I think was an important thing to learn, right?
01:22:06 Bryan: Yes.
01:22:06 Jonathan: I actually dropped out of that eventually. Not soon enough, I had one semester left, which is the stupidest thing. It's like, just stick around and do the last semester and get your degree, but I couldn't do it. I was not-- but anyway.
01:22:19 Bryan: I'm sure they'll let you finish up. You can probably give the commencement address.
01:22:23 Jonathan: I don't like school, so I learned certain things there. What you learn in school is not that practical. There's a mixture, there's ideas. There's a lot of ideas about how you should program and how computers should work and all this. Some of them are right and some of them are actually pretty wrong. You have to go learn which ones are right and which ones are wrong. That's where I did that.
01:22:50 Bryan: You have to have a very lab-intensive computer science curriculum for just this exact reason.
01:22:54 Jonathan: Even then though that helps, but a lab project in school that you would do one semester, that's not the same as like, I'm building a game from scratch with my bare hands for four years. That's just different. We started a company at the hardest possible time, but I also feel like I'm like a programmer who was raised during wartime. I look around today and I'm like, "People can't really program today," because they weren't forced. That's a little bit of a facetious way to say it. People can definitely program in the sense that they type in relatively uncareful things into a computer. Then, approximately the right thing happens in return, but, it's not the same.
01:23:41 Bryan: No, I think you're right. I think that, and in particular, that the era of resource constraint seemed to have ended.
01:23:49 Jonathan: Well, here's a magical thing about games, is that we still had resource constraint. We still do today, because we're in competition with each other, and because a lot of the platforms that we ship on are actually fixed platforms. Like, "Here's the CPU, here's the GPU, here's the memory. You know what all these things are, you know what the speed of all of them are," like a game console. The people who make the game console have an interest in you being able to program it well.
You don't have these super thick abstracted APIs that you don't know what's going on. It's like, "Oh, you actually know when you call this function what the graphics processor is actually doing in response to that," if you actually care enough to dig into that. When I say a lot of people don't know how to program today, I accept certain parts of video games from that. It's a big industry, and there's a spectrum of what people do.
01:24:42 Bryan: No, this is an important point in terms of like, the resource utilization has immediate commercial values. You do understand the metal that's underneath you a lot better.
01:24:53 Jonathan: Again, I'm in a weird space there because, my whole shtick, so there's large video game companies with hundreds or thousands of people. Which is, again, that's still a pipsqueak, tiny thing compared to web companies. A giant, massive, hugely successful video game that makes billions of dollars like Red Dead Redemption 2 or something. Probably, I don't actually know the numbers on that game, but it would be typical for something like that to peak at a thousand people, and that's just like toward the end when a lot of people jump on to try to finish it up.
01:25:23 Bryan: A thousand people, wow.
01:25:27 Jonathan: Probably hundreds for most of development, right? Which--
01:25:31 Bryan: It's a lot of people.
01:25:32 Jonathan: -it's a lot of people, but it's also not a lot of people compared to some companies, right?
01:25:35 Bryan: Sure.
01:25:36 Jonathan: It's weird. It's a lot of people to try to coordinate when you're trying to be very precise about what you're doing and when they're all somehow hammering on the same spot.
01:25:49 Bryan: Right, right.
01:25:52 Jonathan: I don't know, but those are the biggest game projects. My history is much, much, much smaller. The game before the witness that I did called Braid, I did most of it. Then there's a guy, David Hellman who drew the majority of the visuals, and then we had a few other people help out. That shipped on the Xbox 360 in 2008. It was competitive with other games that you could play. It wasn't competitive in the sense of high budget production values. In terms of being an interesting game that you could play that looked nice.
01:26:22 Bryan: It was fun.
01:26:23 Jonathan: Yes, and it was successful on the platform. That's been my thing since then, is like doing a lot with a little in terms of resources, and that's hard sometimes. The weird thing about doing a lot with a little is, because the things we're trying to do are ambitious, we are definitely very much in touch with reality of what goes fast on computers. Most of the work that we do is about making things go fast, ultimately. If we want to get some graphics on the screen, there's ways to do that are very abstracted, and there's ways to do that that are very fast, and those are not the same way. In fact, they're very different from each other. We do the fast way or we try to.
As much as that's possible, sometimes it's too ill-defined. If you're going to ship on a lot of different PCs with different GPUs, it gets harder to know what to do. Our deal is just, we work pretty hard and we try to be productive. The way that I found to be productive, and this is a little bit paradoxical, especially for being on this podcast is like, you can't be that far from the CPU.
If you think every little CPU thing is super interesting and rat hole on doing the optimal job on that thing, you will never ship a large piece of software. I've seen a lot of people do that. I've been in this weird middle place where it's like, for Braid Xbox 360, it was like, "Oh, particle system's slow. I should use some SIMD intrinsics to speed that up," so I spend a month or two learning that and putting it in. Then I'm like, "All right, it's fast enough, I got to move on," because there's just so much to do.
01:28:17 Bryan: That's interesting.
01:28:18 Jonathan: Actually, in retrospect, I'm sure I could have done a much better job on that particle system with my current experience had I time travel back. There's also this thing where computers today are just too complicated. A modern Intel I7 dash whatever random string of digits you have, if you're going to try to actually understand what that's doing in response to your software, it's very difficult. Even using all the tools that Intel gives you, it's very unlike, for example, in the Quake days where it was like, "Okay, a lot of the CPUs are going to run on our Pentiums. It's got this dual pumped thing, so we could, like," I forget what the terminology was, but like--
01:28:57 Bryan: The [unintelligible 01:28:57] right? [crosstalk].
01:29:00 Jonathan: I think of it A and B but whatever.
01:29:02 Bryan: Yes, you're right.
01:29:03 Jonathan: The point is, you'd issue some things for pipe A and then B. You'd move your instructions around just to try to keep those balanced. That was a thing where you understood what was going on, and now, it's that's simply not even possible really, mostly. The number one thing to understand in games, and we're reaching the point because things are so complicated that not that many game programs understand it.
The number one thing is, don't miss your data cache, because you pay-- Again, it depends, but you pay hundreds of cycles for doing that. The absolute worst case is dependent pointer reads where like, "Okay, I'm looking through this point or to get this other pointer that like what--" and it doesn't matter how much speculative execution you have at that point. Probably, most of those cycles are not going to get filled. The problem is--
01:29:53 Bryan: [unintelligible 01:29:53].
01:29:54 Jonathan: -yes. The thing is, most ideas of how to program, both the ones from Academia and also the industry ones, which are a different thing, but industry best practices ways to program also don't really contend with this reality yet, and so, we in the games industry, we have various things, so like data-oriented design. I don't know if you've heard of that.
01:30:17 Bryan: No.
01:30:19 Jonathan: It was started by some people who are not me, but I think it's a good idea. It's basically like, "Look, if you want your program to run well, you need to look at what the data transformations are in design for that, because that's by far, the limiting factor on the processing you'll be able to do."
01:30:33 Bryan: Yes, I understand.
01:30:34 Jonathan: "By the way, when you do that, that doesn't look anything like object-oriented programming for example, because object-oriented is a totally different factoring that will cause you to be very slow, but it also doesn't look like a lot of things that you learn in computer school." In computer science class, they love telling you to allocate nodes all the time, and have pointers between nodes. That's like half of what you learn, but it's like, suddenly, we're in a world where that is very very slow. Then, maybe a lot of programmers don't need to care.
01:31:05 Bryan: I have to ask you, I feel like this is a very own brand question for me to ask you. Have you looked at [unintelligible 01:31:10] I think the--?
01:31:11 Jonathan: I have, a little bit. I actually famously- I have a rant on YouTube for an hour about Russ.
01:31:17 Bryan: Oh nice. I have to go watch it.
01:31:19 Jonathan: I don't know if you know this right about me. I'm also making a programming language now to replace C++, because like I said, my shtick is doing a lot with a little, so building a game engine, which is the thing that runs the gameplay code and all that is, usually, people wouldn't even do that these days because they would like use licensed engines. For both Braid and The Witness, we built our own things. While I was building the witness, I was like, "Yes, C++ is not really a good language to do this." When you're five years into a project-- Witness took six and a half years. When you're like five years, five and a half years in and you're just like, "Oh my God, this is such a slog. When are we going to be done with this?" Which even if you're working on the most exciting thing you ever worked on, if you're doing it intensely for that long, it's hard.
01:32:09 Bryan: That's a long time.
01:32:09 Jonathan: Then to go in and feel like a lot of my time was being wasted by this stupid programming language.
01:32:14 Bryan: By the language itself, yes.
01:32:16 Jonathan: Which by the way, is really the only option for us in that industry. There's good reasons why we use C++, but also, it's a terrible language at this point. It used to be not so bad, but then the direction that they're taking C++ is less and less reality-based, I would say.
01:32:34 Bryan: This is [unintelligible 01:32:35]. My view is that C++ was terrible, and that people who-- because, I mean, I decided-- C++ and I broke up in college, and I decided, we could never be together. People said, "Oh, it's gotten better in C++ 11, C ++ 17," and I'm like, "Maybe that's great for you. I can't go back to C++ because of the way that relationship broke up with me, which is C++ dragging all my stuff into the street and lighting it on fire. We are definitely not getting back together."
01:33:02 Jonathan: I would say that C++ 11 added some good stuff, but after that--
01:33:07 Bryan: -it overshot.
01:33:08 Jonathan: It overshot. Then the problem that C++ has is there's a lot of design mistakes in the past that they have to carry forward, and so everything new that gets added is hobbled by having to deal with all these other things.
01:33:21 Bryan: That is the origin story.
01:33:23 Jonathan: Exactly.
01:33:23 Bryan: It is C++, and just the necessary compatibility with C, and it's like the comma operator. You can overload the comma operator, what does that mean? Nobody knows.
01:33:34 Jonathan: Certainly, if you do it, nobody's going to understand how it's done.
01:33:37 Bryan: Nobody is going to understand. It's got right to left evaluate. It's like, no good is going to happen from overloading the comma operator.
01:33:43 Jonathan: Yes. Anyway, so that's the backdrop of all this. I started making the language that I'm working on in like 2014, towards the end, but it wasn't a serious full-time thing until 2016. Now we're building a game engine that's a new engine because it's in a new language that is in development, and we're doing that full stack of things at once right now.
01:34:06 Bryan: This is Jai? J-A-I, was it?
01:34:09 Jonathan: Yes.
01:34:10 Bryan: Do you pronounce it Jai?
01:34:11 Jonathan: I'm sorry. I tend not to pronounce it. It's a code name, because one of my--
01:34:14 Bryan: Wait, if you don't pronounce it, you're the guy-- you have to just tell people how to-- [unintelligible 01:34:20] pronounce it.
01:34:21 Jonathan: One of my pet peeves for decades, and it got worse once open-source became this weird social thing. It's like, you go on Hacker News or even before that, you read some Usenet posting or some paper and it's like, everybody introduces their project you, and it's like whatever weird name, like Diamond Dust Colon, and then they tell you what the thing does. Then you go check it out and it sucks and it hasn't had that much work put into it, and it's maybe not that good of an idea in the first place, most of the time. It's like people put all their effort into the cool name and the idea that they're doing a project, and then putting it out in the world and getting people to sign up for their project that hasn't really had that much work put into it. I am doing things in the opposite way.
01:35:08 Bryan: There you go [crosstalk] absolutely not pronounceable.
01:35:12 Jonathan: Well, it's not that it's not pronounceable.
01:35:13 Bryan: No, I'm sorry.
01:35:13 Jonathan: I don't use it because it's maybe not the real name.
01:35:15 Bryan: Got it. Fair enough.
01:35:17 Jonathan: We haven't released this language to anybody even though it's been in work for five years. It's been runnable for the whole time. It's been expanding in feature set and reliability. One of my peeves about open source again--
01:35:31 Bryan: I have to say I also like about that is, I feel there is too much emphasis, especially in open-source on winning, and it's like, my language needs to win, and my database needs to win, and my software needs to win. It's like, actually, your software, if it's useful for you, it can just-- I love the fact that you got this language that is usable that you're using that you haven't yet released.
01:35:54 Jonathan: I went to Berkeley, and there was this idea of the Berkeley approach versus the MIT approach back then, and that the Berkeley approach always wins. The MIT approach was, you craft some beautiful Jewel in your backyard or in your garage or something for many years and you make it perfect, and then you release it, and the Berkeley approach was like, "Oh, you just do something and you let people use it." Sort of like the minimum viable product that web people do now. That was considered to be the right way to do things, but situations change.
I think we're now in a situation where everybody in the world is flooded by low-quality software, and everybody wishes that they had higher quality software, at least people who make software I think. We're making a game, games have a lot of things they want to do, a lot of those things are potentially stuff that a library could do of some kind, and so, let's go out, whether it's maybe to do some constructive solid geometry or text layout or something. There's a lot of different little sub-jobs.
If I go on the internet, what is the state of the art of what people out there are doing for this task? Very often I will find a number of things that claim to do the job. Some of them actually do it to an okay level and some don't, and a lot of them don't really work for high-stress situations, and a lot of them don't even like frickin compile anywhere. Just the amount of swimming through a sewer that I have to do to even figure out, "What is the thing that I can seriously consider to maybe do this job versus writing it myself?" That is a huge investment, time and energy investment.
Then maybe I start using something and then I find out later that it doesn't do a very robust job of solving the problem, but it took me a month to figure that out, because that's how much investment I had to put in to get to the point where the problem was hard. It's like, I've developed a very strong distaste for that. I feel like, if you put some source code out into the world and claim that people should check this cool thing out and it's like not actually doing a good job at what it does, you're creating an ecological disaster because of the scaling factor. How many people are going to download? How many people are going to invest time in your thing before they figure out it's not actually good?
01:38:17 Bryan: The npm ecosystem is going to be the canonical example of this problem for you, I imagine?
01:38:22 Jonathan: Sure. I have very little experience in that territory
01:38:24 Bryan: Oh, God, you should avoid it.
[01:38:25] Jonathan: It sounds-- that last part and all that stuff.
01:38:30 Bryan: From a psychological safety perspective, you should avoid the npm ecosystem, because it is the absolute very worse. There's a spectrum, and I do think that like-- I don't think the Go ecosystem is probably in the middle.
01:38:47 Jess: Of good software?
01:38:49 Jonathan: In the Node ecosystem, there are 15 things that do this task, none of them well.
01:38:57 Jess: Okay, that's it.
01:38:59 Jonathan: In the Go ecosystem, there are six things to do this task, some of them, okay.
01:39:04 Jess: Some of them [unintelligible 01:39:04] to make good. I think that's just a testament of the fact that JavaScript is around longer.
01:39:10 Bryan: I totally agree with that, and JavaScript's core value is growth, is metastasis, and, as a result, they want to make everyone be able to write a program, which I think is loadable at some level, but it means that there's a lot of garbage out there.
I have to say, it's one of the things that, again, I know I'm being very own brand here, but is one of things I like about Rust, is that it's so much harder to get something to work, and it's just like the cognitive load. It forces you to have the true cognitive load of your software. You have to absorb when you're developing it as opposed to being able to just poop it out.
01:39:47 Jonathan: I agree that that's good. The thing that I don't like so much about Rust and several other languages, okay, the mission statement of Rust broadly speaking I think is very good.
01:40:00 Bryan: Fast and safe.
01:40:02 Jonathan: Yes. We're going to improve-- let me make it even more general. Who knows? Rust people might not agree with this restatement. The broad thing that we need to work on is, we need to make software work better generally. We need to make it more so that when you write a program, you know that it's correct to a greater degree than today.
It would be helpful to do that in ways that are not the ones that have been well-trodden because we have seen those ways before. For example, a garbage collected-- a list variant or something, it's safe in certain ways, but it's actually very unsafe in other ways, because lisps, for example, were not traditionally statically type-checked, and who realized that that's actually important?
Rust, I think has a good set of ingredients there. The problem that I have with it is, when I'm working on really hard stuff, I don't exactly know what I'm doing for a long time. If your cost of experimentation is driven too high, it actually impairs my ability to get work done. 
01:41:10 Bryan: Yes. I think that's fair.
01:41:12 Jonathan: My approach that we're doing in the language I'm working on is different. You have very expensive metaprogramming facilities, and you can use those to build your own correctness checking for your program that you traditionally would have needed to make a compiler extension to do, which is like, that's pretty far away from what people do day-to-day, and they just don't end up doing it, even if they could have.
What happens is, your meta-program gets information that normally would only be internal to the compiler. You get a message loop while you're compiling, and it's like, Oh, this declaration just compiled, it's a procedure. Here's the types of the arguments, here's the types of the return value. This identifier maps to this other thing. You could start having house rules.
01:42:09 Bryan: I've compiled time logic that can enforce different constraints.
01:42:18 Jonathan: Yes. You can decide what that is later. A video game example, because this is motivated by the reality that I come from. We have these game engines and an object in a game world. We don't use the word object, because that got commandeered by object-oriented.
01:42:33 Bryan: Commandeered slaughtered.
01:42:35 Jonathan: Yes. We call them entities, even though somebody else-- [crosstalk] like my coffee cup is like an entity. Entities have data associated with them and so forth. You might have different entities like a person, you probably want a lot of different things to happen for a person than like a soccer ball. Those are very different. We tend to make those different types of entities, and somehow they end up having different behavior, and so forth.
People have different ways of representing this, of course, but the way that I tend to do it is like a very shallow inheritance thing, where there's a base, that's entity, and it's got all the things that are common to everybody, and then one level sub-classing, maybe. Other people do that a different way, but I think the way I do it is probably among the most common.
01:43:23 Bryan: Are you inheriting the interface or implementation or both?
01:43:26 Jonathan: It's not really about interface and implementation, it's just like, Look, there's the data, do what you want with it. There's not getters, setters and whatever, usually. I don't find those to actually solve any problems.
01:43:41 Bryan: Amen.
01:43:42 Jonathan: Usually, an entity will have an ID, it's got some handle that used to look it up, it's probably an integer or functionally an integer, maybe it's a couple fields packed into a thing. Because there's a coordination problem, you have a lot of things moving around in a game, something gets destroyed, you blow it up, or it gets paged out to another area of the world that you're not simulating anymore, or something, and you have to work within a limited amount of memory.
You have to destroy these things, but the nature of a game is all these things want to coordinate with each other all the time. If you just naively delete something, then some other entity that's trying to follow that thing is now following an initialized memory or something, [crosstalk] so, what do you do?
Often, you'll refer to things with a handle. "Modern C++ people" I'm putting air quotes as I say that because I think it's a silly phrase, but those people would say like, "You should use some weird smart pointer." That's not actually what you want to do because you want to have very clear and authoritative control over, What is the memory for this thing? When is it live? When is it not live? Exactly what happens at exactly that moment? Smart pointers are more about hiding things, and magically stuff happens later when I don't exactly know. It's the wrong thing.
Anyway, you have some integer ID that you use, and you say, Hey, give me the pointer to the entity that corresponds to this ID, like say I'm following this entity. I get back that pointer, or it says, Oh, it doesn't exist, and because there's a specific time at which this happens, you're going to handle the non-existing case because it's obvious. Then, it's like, Okay, I want to start looking at all this data, which might be quite a lot of data, I might need to use a lot, so I take the pointer for a while and do stuff with it. Now, we have a safety problem.
01:45:32 Bryan: When are you done with this memory?
01:45:34 Jonathan: Yes. In games, the way that's traditionally handled is there's a very natural barrier, which is the end of the frame. We do a bunch of stuff over and over 60 times per second, or 200 times, whatever, right. At the end of that frame, we pretty much know that--
01:45:49 Bryan: It's all garbage now. [laughs]
01:45:52 Jonathan: We're not really hanging on to anything, it's a very clean cut.
01:45:56 Bryan: Yes, right.
01:45:57 Jonathan: It's a very reasonable thing to say, It's fine to do that stuff as long as you don't hold an entity pointer across a frame boundary." Now, that's not a very generalizable rule, because, what's an entity pointer versus a pointer to something else, your compiler doesn't know that, but you know that. When the new guy shows up, or the summer intern shows up and writes some code where he puts that entity pointer into a data structure that--
01:46:23 Bryan: That actually is driving across the frame.
01:46:25 Jonathan: Yes. Like some half table that's sitting around, that's going to be a problem. That's a very practical, real problem. It's not an academic made up problem. You have to consult that, your meta-program can say like, You put an entity pointer in this data structure, and that data structure is not in this whitelist that I have over here. Error, you don't compile. You can start solving the very specific problems that you have without introducing general friction. Is that better than the rest of the approach? I don't know. I think it will be, but I certainly offer you no proof of that statement.
01:46:59 Bryan: Right. I think it's interesting because it's grimier a little bit in that it is less academically pleasing. Because it's like, Oh, but I should have a type system that it should be the type system that should enforce that, as opposed to this program to logic, because effectively, you have a dynamically programmable type system.
01:47:18 Jonathan: Yes. I don't think of this checking as being part of the type system.
01:47:23 Bryan: Okay, right. Fair. Either way.
01:47:25 Jonathan: The type system, it's like what you would get if you went back to somewhere between C and C++, and then made all the decisions the right way instead of the wrong way, about what automatically cast to what.
01:47:37 Bryan: Yes. You're allowing it yourself too, you're saying, I'm going to have Programmable Logic about what can be cast into what, not in a smart pointer, but it presumably [unintelligible 01:47:47]?
01:47:48 Jonathan: No. Not even, really.
01:47:49 Bryan: Does that intern that made the mistake, do they know that compile time?
01:47:54 Jonathan: Yes.
01:47:54 Bryan: Interesting. That's cool, I like it.
01:47:57 Jonathan: It's not through the type system.
01:47:58 Bryan: Sure. Right, exactly.
01:47:59 Jonathan: The type system is made available to your arbitrary code, which then does this thing.
01:48:05 Bryan: That's very practical, I think, it's neat. Is the intent to get this broadly out there?
01:48:13 Jonathan: Well, Closed Beta begins by the end of 2019.
01:48:16 Bryan: Okay, oh, that's-- [crosstalk]
01:48:20 Jonathan: I don't know when this will air, maybe it'll already have happened.
01:48:23 Bryan: It would be open source?
01:48:25 Jonathan: Not initially.
01:48:26 Bryan: Sure.
01:48:27 Jonathan: I think in the long term, if you want people to use a programming language, they have to be able to outsource.
01:48:30 Bryan: The one thing it does remind me of a little bit is D, mechanically from D, not in terms of what D actually did.
01:48:37 Jonathan: D makes a lot of really decisions that are different.
01:48:41 Bryan: I think the meta-decision that Walter Breit made was to have that be the last proprietary compiler. I think if D had been opened five or six years earlier--
01:48:54 Jonathan: It might have taken off.
01:48:56 Bryan: I think it would have had a broader relevance. Again, I hate the idea that we all need to pick winners, I think it's ridiculous. If it's a solution for someone's problem, that's great. I think it sounds interesting.
01:49:11 Jonathan: Yes. Going back to Rust for a second, one of the things that I like about it like I said is, we're going to approach this problem of memory safety through compile-time management as opposed to runtime management.
01:49:22 Bryan: Yes. That's right, but it does force you to really accept some limitations.
01:49:29 Jonathan: Yes. That's a non-trivial statement to make that has a lot of implications. At least, it's starting to rethink some stuff.
01:49:39 Bryan: I think you'd have a good point because the system that Rust struggles with is where you've got a lot of interconnections and interdependencies. To the point where it's advised, I think rightly so, that you want to get away from these complicated object graphs where everyone's got a pointer to everybody else, because those are going to be multiply-owned data structures, and Rust is going to bridle with that. You can get it to work, but it's ugly.
01:50:05 Jonathan: Then a lot of what people do sometimes it seems like they don't realize that they're skirting around the system, but they they really are. For example, I mentioned I have a rant on YouTube. It's not an angry rant.
01:50:19 Bryan: This what I see with my rant too. Thank you for saying that. It's like a rant with a glint in the eye.
01:50:24 Jonathan: It's more of a rant in the sense of unprepared. I spoke for an hour unprepared. Basically, another company in the games industry was experimenting using Rust. There are a few people doing it, and we'll see how it goes, but for now, it's the early stages of an experiment. One of the engineers from one of these companies did a presentation at Rustcon, I guess. Is that what it's called? Where she said, "Hey, here's what I like about Rust because it led me toward this design of a way of doing this entity system." So that entity problem that I was talking about before.
01:50:56 Bryan: This is a talk at Rushkoff, 2018, I think.
01:50:58 Jonathan: Something like that.
01:50:58 Bryan: Pretty recent. It was a good talk.
01:51:01 Jonathan: What I said before about what happens if one entity is following another one and one of them goes away and you have uninitialized memory? That's exactly the kind of memory safety problem that Rust is supposed to help you figure out is there. This particular system, I don't want to go super much into the details, but the point of it, there's this thing called entity component system, which is a different structure of doing this. Mostly, what that phrase means these days is, it's laid out in a data oriented way. If you're going to get the memory for a new entity, it's like maybe in some pre allocated arena with all the things of the same size.
If you were to allocate and deallocate, you could grab something out of that spot and put it back and there's no fragmentation or anything like that. This entity-component system that was being-- the virtues of which were being extolled in this talk was essentially a custom memory allocator just where everything was the same size. They were the same type so that the type system wasn't getting angry.
You still could have a use after free bug that the compiler wouldn't catch because the compiler just doesn't know this is a memory allocator. I keep seeing things like that where I'm not sure that the amount that's being paid is worth what is actually being gotten. However, I greatly respect the fact that Rust is going in this direction, and I wish a lot more people would. We need to have some new ideas about how to program well, because we've been following the old ones for a while and we've seen where they go, and it's not that great.
01:52:42 Bryan: It's not that great. I think that we may well see, and I should think we should see some bifurcation in languages around purpose, and around where-- because I do think that Rust struggles, because I've thought a lot about like, "What does it mean to rewrite the operating system in Rust?" There are a lot of things that will be grisly, and it will have limited utility and limited payoff because there are so many multiply-owned data structures. When data structures have true multiple ownership, it means that in Rust, you're going to have to pull tricks to get that to work.
But, there are lots of data structures where you have multiple ownership or you don't actually need to have multiple ownership, but if you rethink your problem and recast it in a way where you've got that ownership going one direction, and more things are singly-owned, then Rust says, "Hey, if you can recast your problem this way, in return, I'm going to give you a high performing artifact that is safe."
01:53:37 Jonathan: I think that's valuable, however, I think also, there's always people who are very overzealous about any particular idea. I think the people who are overzealous say that that's 100% of it. You always can make your program better by getting rid of the multiple ownership, and that's not true in my experience.
01:53:55 Bryan: I think that's fair.
01:53:57 Jonathan: Sometimes, your problem is your problem. Engineering means that you're confronting reality, and reality is what it is, and you don't get to decide what it is. As an engineer, you're dealing with reality as best you can.
01:54:14 Bryan: If your problem has that tight interconnectedness, I think it's--
01:54:18 Jonathan: Going to a simpler example that takes the Rust part out of the equation for any Rust enthusiasts who are listening. One thing people will say is like, "Oh, your program shouldn't have global state at all, because global state invites bugs," In all the ways that we've been told. Okay, that's a true statement. All things being equal, if you have global state that you don't need, it's probably bad. You should probably get rid of it, and I agree with that.
But actually, games have tons of global state. Actually, a lot of the problems that we need to solve, the actual problem is a global state manipulation problem. Pretending that it's not by saying, "Look, I have a functional language and I'm going through seven layers of things so that I can avert my eyes sufficiently from the fact that I'm actually just manipulating Global's at the end of the day." That's just an obfuscation. It doesn't actually solve any problems. It certainly doesn't make you fast.
01:55:10 Bryan: It's like global washing.
01:55:11 Jonathan: That's a good term. We won't start talking about Singleton's and how they're totally not Global's.
01:55:21 Bryan: Right, exactly. I think it's a very good point, that your problem is what your problem is, and the task should be to find something that is tightly tailored to that.
01:55:32 Jonathan: When I get into arguments with people about this, I try not to because it's just hard, because I've seen problems that are multiple ownership problems, fundamentally, they just are. You can't tell me to refactor that-- It's like saying, just refactor your program so it runs on the cell processor fast with your problem. It's like--
01:55:55 Bryan: Wait a minute. I really feel this way around doubly linked lists, doubly linked lists are a multiply-owned data structure, and I think that Rust advocates do themselves a disservice when they say, "You shouldn't need a doubly linked list." It's like, "Hey, screw you, I need a doubly-linked list for this problem." My problem is-- I think that I would say that most people in the Rust community are much more balanced about this, of saying, "Hey, you can do that if you need to, but if you can possibly recast your problem, if you can let go of that particular way you've implemented it for a second, if you can recast your problem in this other way, you can get this great dividend."
But I think there are problems that are that are not going to be able to be recasted that way.
01:56:42 Jonathan: But that's okay. We're figuring it out. Does anybody think that programming, assuming that human race exists in 300 years or something, this programming 300 years from now look like programming today? I don't think it does.
01:56:58 Bryan: Oh, that's a great question.
01:56:59 Jonathan: I don't know what it looks like. I have some ideas about what it looks like. You were talking before about everybody can program kind of things. Like President Obama, everybody should learn to code. On the one hand, I think people are right when they say that that's a computer skill, but on the other hand, that's different. We don't say everybody should build a bridge that traffic drives across.
01:57:22 Bryan: We also don't say that everyone should write literature. I think everyone should be able to read and write.
01:57:27 Jonathan: Everybody could write their poetry in high school or whatever. That's not bad, but we don't say that everybody deserves to have their novel read by the nation. There's just some clarity there that we have not reached when it comes to software.
01:57:43 Bryan: I think you're right
01:57:45 Jonathan: I think it's good for people to have technical skills to know how to program I think. What does it look like when people who are not bridge builders, when they program I think it looks different from when bridge builders program. In games we have these systems that are visual programming kind of things, like blueprints in Unreal or things like-- It's like connect boxes with some lines to do a thing that looks like a circuit, but you get around infinite loop problems and flow control problems, and you don't have pointers or anything, very simple. Still a limited model, but I think the future for non-low-level programmers starts to look like that eventually. It doesn't look like JavaScript, for example.
01:58:27 Bryan: I think that computational literacy actually is important as a universal attribute, but that doesn't mean that everyone is going to be at arbitrary depth. It certainly does not, and doesn't mean, should everyone be writing Rust? No, probably not, actually.
01:58:42 Jonathan: Certainly not everybody, but should everybody who's building bridges be writing Rust? Rust people would argue, yes.
01:58:46 Bryan: Yes, I think yes.
01:58:48 Jonathan: I would say I don't 100% agree, but we shouldn't be writing c++.
01:58:52 Bryan: That, Amen. There we go. The 300 used thing is kind of interesting, because I still believe that we are in a golden age of software still. I think that we are laying down track that will be especially as we take some of these big and important iterations, I do think Rust is an important iteration. I think that JAI, J-A-I, whatever it will be. Whatever we renamed Diamond Dust.
01:59:20 Jonathan: Diamond Dust.
01:59:21 Bryan: Is potentially an important iteration, I think that we are going to take some of these big important iterations, and I do think we're going to be building things. The Romans laid down a lot in terms of civil engineering, and the Greeks laid down a lot in terms of philosophy and how things are constructed. I think we're laying down a lot in terms of how future software is constructed.
01:59:47 Jonathan: Maybe. Yes, and no. One of the things that I can show here. I have a different video on YouTube. It's a lecture I gave in Moscow this year in March called Preventing The Collapse of Civilization, where I do agree with the fact that we're producing a great deal of software, but I note that these days, we don't really expect it to work that well. Computer bugs have always been a thing, but these days, our expectations seem to be lower and lower.
02:00:20 Bryan: I do take issue with that in that I think our expectations should be higher and higher in that we should be writing software for permanence.
02:00:29 Jonathan: Yes, and I agree with that and the problem is we're not really. There's all sorts of weird stuff going on. You mentioned NPM kind of things. My understanding of the way NPM works is when you build something--
02:00:41 Bryan: In such a charmed life.
02:00:43 Jonathan: Yes. You really have stayed away. When you build stuff, the tradition is you just pull down the newest version of any dependency that you have, and of course, you have like 37,000 dependencies. Everything that I've learned from making video games, which are very complicated and have to work well is that the way you ship software that works robustly is A)-- all the obvious things. Of course, you test it, but what does that mean? It means you test exactly the thing that you've shipped. It means if you update some submodule, you don't do that without fully testing it. That's not automated tests. That's like playing it for weeks and weeks, but also, it means you know what's in there, and you know how it works, which means you probably don't have 37,000 dependencies. It means that once things are established to work, you harden it. You say this is the product.
We're not going to go have a summer intern swap out parts of this product when nobody's looking in six months because the thing that we have vetted--
02:01:46 Bryan: Is done.
02:01:46 Jonathan: Yes, this is the thing, and that's a very counter to what the web people are doing these days.
02:01:58 Bryan: Its interesting. I see what you're saying because one of my criticisms of games, such as it is, has been that it's a lot of software that's thrown out, but because there is this emphasis on completing the artifact, and not constantly evolving it, there is a higher bar for the correctness.
02:02:17 Jonathan: We throw out a lot less than we used to. Back in the Doom/Quake days, we would throw everything out every time because what we had to do was so different. Nowadays that doesn't really happen anymore. The thing that weirds me out, and the more and more-- The thing I've been doing for the past year or two, is like looking around and saying like, "Wait, where are we with respect to all this software stuff? What happened exactly?" For example, if you go back to the 1970s, invention of Unix, or something like that, what is that? Operating system? What does an operating system mean? It's the thing that just helps you run programs on this computer. That was relatively laborious to start up programs and get them going. Now we have a system that helps us do this.
We're 50 years later, it's a long time, and we have operating systems still and I don't seem to be able to consistently run software on them. Whether it's Linux or Windows or something like that, distributing a program on Windows that I will know will work on someone else's Windows computer is really non-trivial. I don't care what the program even does once you start getting into things like how it interfaces. Do I know that it's going to start up correctly or it's going to pop up some missing DLL error box, it's hard to know that actually.
The only real way you can know that is by abandoning a lot of the stuff Microsoft is trying to get programmers to do and having very little in the way of dependencies and really like focusing down on that, but nobody steps back and says like, "Wait, why is it so hard to run a program on Linux?" Linux has a different aesthetic. People expect that you don't distribute precompiled binaries there.
One of the reasons is just that it's so hard to do that and have it actually work for everybody, and not just-- Linux people will say, "Oh, it works for me. Ha-ha," whatever. When you have to answer support calls, you really get a clear view of when things are not working right and you really see on this percentage of systems, on 8% of systems, this thing just doesn't run. That's a huge disaster because that you'll get killed by support calls. Anyway, I think you worked at Docker, right?
02:04:50 Jess: Yes.
02:04:51 Jonathan: Containers are one of my pet peeves.
[laughter]
02:04:54 Jess: Somehow, it's great.
02:04:55 Jonathan: If you go back to the 70s or 80s, you had a couple of computers, they were the same kind. You just copy the executable and run it. I remember doing that in college. Then somehow, we've made this several layers harder. You're actually linked against dynamic libraries, which seemed like a good idea at first, but now this other system has different dynamic libraries so it may not run even though they're named the same and you don't bring them with you.
02:05:24 Bryan: Containers are reacting to that. You guys are trying to get you back to that model you had.
02:05:28 Jonathan: I have no problem with that as long as somebody says, "Wait, this is just covering up for a problem that we solved. Maybe, eventually, we should go back and collapse these layers and resolve the problem." But if you go on Hacker News or something, where the 24-year-olds hang out, they think this is advanced software technology, that you have a container and that provides a new layer that gives you new capabilities. I'm like, "No, dude, I could copy a program over the network and run it in the 70s just fine." We lost that capability.
Actually, one of the points that I put in this Russia talk was it's even weirder than that, and especially in games. But broadly speaking, if you have a Windows PC and a Linux PC and a Mac laptop, and a PlayStation 4, those all have compatible CPUs in them. If you have a machine language program, that you just magically teleport into the memory of those things, and if it doesn't go out to the operating system to do anything, it's just computing a result, it will run on all four of those things with no problems, perfectly.
Yet we have this capability of perfect cross-platform compatibility by virtue of the platforms being the same, but whatever, and we have somehow subtracted that at the operating system level. For what reason? Hopefully a good reason. No, it's just like the executable format is a little bit different and whatever. Reasons that arent-- All these operating systems are doing the same thing. They're just doing it in incompatible ways that don't really buy you anything. The really horrible thing for the future is we are now in an area where this kind of infrastructural decisions are being made by companies who don't seem to have any incentive to cooperate anymore, in a sense. Going back to the C programming, which a pretty good idea back when it was made, I guess. A lot of people would think it wasn't particularly good.
02:07:39 Bryan: Anyone who's been complaining about C is ordered to spend time in the languages that immediately [unintelligible 02:07:44]
02:07:45 Jonathan: There are reasons why C was successful. Let's leave it that way.
02:07:46 Bryan: Absolutely, yes. I mean, the C is way better than what comes so forth.
02:07:50 Jonathan: Although I wish that they had actually type-checked parameters [unintelligible 02:07:55], that would have been great. The open paren, close paren thing was not good.
02:08:02 Bryan: It really wasn't. [laughs] It was bad.
02:08:05 Jonathan: That was my first C experience. I was like, "Why is this crashing?" It's like, "Oh, because a signature is optional?" Its like yes, right. Anyway, but back then it was like, Look, we have this language, we can compile for multiple CPUs. The CPUs might be quite different. We might have to make some allowances in the code so we do some [unintelligible 02:08:26] around small portions of the code where if we're running on something that doesn't have a certain size integer or something, do this, otherwise, do this, whatever. We're all very familiar with that. That is a good model. That got us a long way. Eventually, that got replaced with this interpreter languages model, which I could rant for hours about why that's weird and not what we think it is but I feel like we're going kind of long. I don't know how long this is supposed to be.
[laughter]
Anyway, the problem is now we've had this new hardware introduced, like GPUs. GPUs are very fast at doing the thing that they do, and then your job to render graphics is to talk to the GPU or to mine Bitcoin or whatever you're trying to do, right? How do you communicate across that barrier? Going way back, it was just a data communication. You would upload your image data for your texture maps to the GPU, and then you just send commands through a command buffer where the commands were just like some bytecode that says draw this triangle or something. It was pretty primitive back then.
It's gotten more and more complex where now it certainly rivals as a CPU or exceeds a CPU in complexity. We have programming languages for that. We call these shaders, which that name just means it's how you would compute the light on a surface originally, but it doesn't make sense because now we have computed shaders, which just means it's the program that runs on the GPU that runs an arbitrary function, whatever. All of these languages are being done by either GPU vendors or people who are trying to standardize their graphics API or people who are doing both, operating system people, GPU people. We have the opposite of C now. What we have is I can have a system with an Intel CPU, and NVIDIA GPU, hard drive, whatever.
If it's running Linux, I have to use one shading language, because I'm using, let's say, OpenGL or Vulkan, to do the rendering. If I'm on Windows, I'm using DirectX to do the rendering. I have to use a different programming language. I can't compile the same language for a different target. It is a different programming language. That, by the way, in much the way, operating systems are different for arbitrary reasons but they're all doing the same thing. All these shading languages are different for arbitrary reasons.
Now we do all this transpiling, from one shading language to another like in the background. It's hard to have a serious program, you can't program in the same way anymore. Nobody-
02:11:07 Bryan: That's getting further away from the hardware.
02:11:12 Jonathan: There's no adult supervision, like nobody's looking around and saying, like, "Wait, what?" These programs are actually simpler. C programs were manipulating data structures and going into the operating system, and all that. Shader programs are actually simpler. They're just mostly doing math-
02:11:26 Bryan: Computation.
02:11:26 Jonathan: -and outputting numbers. That's a strict subset of what we used to do. You start doing weird data structure stuff these days, because GPUs are more powerful. When you do that, it's in a more streamlined way that is-- it's just simpler. It doesn't require the kind of iron behind it. You're programming to the GPU as opposed to expecting the GPU to come to you.
Nobody's looking around and saying, "What? Why is this happening?" Certainly, nobody is trying to prevent it from happening. Imagine if just like a SUN workstation, use a different programming language from an Apollo workstation, which is a different programming language from SGI, what would have happened? I don't know, but it would have been a mess.
02:12:13 Bryan: I think that tension is what leads to these revolutions. What came before C was a mess. It was people doing exactly that where the different language that I have on these different machines was the assembler. The assemblers were different for all these machines, and C was what came in. We could say like before Fortran or something that was the situation.
02:12:42 Jonathan: Did enough people object to Fortran that they just would rather be an assembler?
02:12:46 Bryan: Well, for systems programmers, Fortran was not a real option. Operating systems themselves had to be written in the assembler of the machine. That was C's gift, is that you can now write a portable system software. I think that there is still so much to be had in new computer programming languages is because we have not yet-- you see this with Rosten systems programming, and maybe with the future diamond dust. It gave programming where it's like there actually is innovation to be had.
02:13:26 Jonathan: There's a lot, theres a lot. I'll give the short version of my interpreted languages spiel, because we're roughly contemporaneous, you'll know where I'm coming from on this. In the '90s, we were still under the impression that like Moore's law is infinite.
02:13:37 Bryan: Yes. This is the true golden age of Moore's law.
02:13:42 Jonathan: There's this history of programming languages that had held up to that point, which was back in the olden days, we programmed in machine language. That was just very laborious. We made assembly language, which is a higher level text representation, compiles down. People these days, don't think there's much of a difference between those two things, but try it, it's really different.
Then assembly language is still very mired in details. Then we started having higher level things like Fortran or C. Then maybe, depending on what political party you belong to, maybe Lisp was the more powerful next step, or maybe it was like modular or C++, whatever.
Basically, the point is, there was this way that we had been proceeding that was obviously true, which is that the higher level your language, I'm, again, putting that in air quotes, because we still don't exactly know what that means. The higher level your language, the more powerful the programmer is, the more abstracted they are from the details of what's happening, and then the more productive they could be.
Then, the problem is we made a conflation in the '90s, which is higher level, which is something about power and expressability, and far from the CPU, because those things had been correlated. We just started making all these languages that were far from the CPU and they seemed higher level, but in ways that are actually a little bit trivial.
I could say string plus an integer, and it'll convert that to a string. That for the first 10 minutes when you sit down doing that, that seems really cool. Does that help you solve hard problems or does it get you started faster on easy problems? It's the latter one. It actually causes hard problems later, because you have no type system. Does this variable exist? No, let's make a global variable that's the empty string because you type that somewhere.
02:15:44 Bryan: You are a math concentrator not a clear science concentrator. You might not have gone through this kind of youthful experimentation with operator overloading. This is what Johnathan does, and it is for you, because the first thing you discover operator overloading, it just seems like awesome. Then, at some point, you need to realize that actually, this has not made it easier to solve hard problems.
02:16:04 Jonathan: I would even go more general than that. We had all these kind of very managed languages at that time, like Tcl was one.
02:16:14 Bryan: There you go.
02:16:14 Jonathan: That's in the extreme where everything is a string all the time. Tcl programs never would work two months later.
02:16:19 Bryan: Oh, by the way, Tcl is alive in order things adjusted I've been doing is we've been doing a lot of low level stuff with in terms of the ETA and FPGAs, and so on, where Tcl is alive and well, and thriving.
02:16:30 Jonathan: People use that?
02:16:33 Bryan: Oh, my God.
02:16:34 Speaker 4: No, we get like software that generates Tcl for these FPGA synthesis. It's insane. I've never seen more Tcl in my life.
02:16:41 Jonathan: That sounds good. Perl from that era, Python. Pythons still in heavy use today unlike those-- Well, I guess, you're telling me Tcls in heavy use. Python is still used. A later variant of Python is used by many, many programmers. The thing is like how high level is Python really?
Probably higher level than C. I would agree with that. It is high level as people think it is. Is it high enough level to pay what we are paying to run all these Python programs? I'm not sure, because there's multiple things that happened in one time. One is this programming language, it's a lot slower, because it's running, interpreted, and all these things.
Also, there was a different community that started happening around that time, where source code was shared much more readily, and all of this. Part of what's appealing about those languages is just how fast you can get started, because there's just a lot of code, similarly with JavaScript, and all this stuff.
02:17:42 Bryan: Boundaries included.
02:17:43 Jonathan: JavaScript is so weird. That was not ever supposed to be a real programming language. It was supposed to just be like, this is a way you do some simple IF statements on a webpage.
02:17:54 Bryan: Well, and JavaScript, its birth is in its own kind of metastasis. It was not supposed to be what it is, in fact Brendan Eich never wrote a book on it. This is one of the--anyway.
02:18:08 Jonathan: The point I was trying to get at is just there's two parallel stories, really. There's that one story of like, here's the sequence of programming languages. As the programming languages get bigger and slower and farther from the CPU, that's okay, because CPUs are going to get faster forever, and we become much more productive.
Are we more productive in Python? I'm not sure. You can keep seeing all these examples. Dropbox published this thing in early 2019, about like, "Hey, here's the story of us migrating from Python 2 to Python 3, our 1.2-million line program for desktop." I'm like wait, what?
[crosstalk]
02:18:48 Bryan: Theres so many questions. What is up in the back?
02:18:49 Jonathan: I don't mean to single out Dropbox, because if you just start looking around at this stuff, you see it everywhere, you see so much code for all these things. I'm like, "Wait, if this language is so high level, why do you have so much code to do such a small thing?"
What you see when you look around, I claim, I haven't done a double blind, triple reproduce study on this, but it looks to me like the productivity levels of Silicon Valley engineers are historically low, actually, in terms of what they produce. Not necessarily in terms of lines of code, the lines of code is very large, but in terms of actual functionality produced per engineer, it's low. Something went wrong.
02:19:28 Speaker 4: Just because everyone always has to be hustling. No, this is the hustling.
02:19:33 Jess: I know.
02:19:34 Speaker 4: That's fine. This is the long shadow of Uber and always be hustling where everyone feels like, "I need to be productive today." It is better for me to regurgitate code than it is for me to reflect on a hard problem. I do think that is right now very deeply entrenched. At some point when you have an order of magnitude more code than you should, which is not the order of magnitude that computer scientists are supposed to be thinking about order of magnitude of speed or something. Not as good.
02:20:01 Jonathan: Magnitude of code is a weird concept. Doesn't that have to kill your company eventually on a long enough time horizon? Maybe it's just longer than people are thinking. Regardless of that, regardless of the business case for that, which is something that people will argue with all day, there are supposed to be people who are the custodians of the field.
We are the people who really care about computers, trying to make sure that computers are good and the way we program is good and all that stuff. I don't feel like enough of those people are looking around and saying, "Wait, we're in crazy town right now." The claimed benefits of all these things did not happen/ Why not?
Maybe they happened 10% or something. Then there's a whole other thing, which is if you go back to something like C-- Like I said, my initial user experience with program AC was horrible because initially it was KNRC. Maybe it was NCC because this was 89, 90 I'm not sure. I was learning from the KNRC book so you still didn't type procedure prototypes or whatever.
The point being there are all sorts of dumb crashes, and then even later, all sorts of dumb things. The thing is it's very easy to do NC having an initialized variable. I put it on the stack. I didn't set it and I used it later. Many, many, many programmer millennia were wasted debugging that kind of thing, Im sure. If you were to compute the amount of time--
02:21:37 Bryan: That's entirely preventable power problem.
02:21:38 Jonathan: Yes, it's trivial actually.
02:21:40 Bryan: It's like the computer knew what it was doing when it did it.
02:21:42 Jonathan: Solving 100% of that is not necessarily easy, but look, have a debug built where for local variables, you have an additional bully in or something, and just add some instrumentation code that checks if you use that and set it [unintelligible 02:21:59]
02:21:57 Bryan: This is what you do have to like about RUST. What I do like about RUST is that it doesn't actually differ to a linter. Actually, it forces a cognitive load right back on the programmer.
02:22:11 Jonathan: The thing that I like about the mood today is we're starting to realize that these things are problems. Even if you go back to [unintelligible 02:22:17] or something, they have that kind of thing in there now. The point is we went many decades without that where you're just like, "Maybe it's why I don't have that much hair anymore is because I was pulling my hair out in the Apollo lab trying to figure out why my C program is crashing. A lot of these languages were designed later including probably stuff like Java, which I also don't have that much experience with but I assume you do having a son. [crosstalk]
02:22:43 Bryan: No, I was always at Java Malcom 10 unconscientious objector.
02:22:50 Jonathan: Anyway, though a lot of this thing that happened was a reaction to stuff like C. Look how terrible it is to program in these languages. I will say 95% of the unpleasantness was actually completely unnecessary if anybody who is making those compilers had cared about the program really.
02:23:11 Bryan: I think you're right. I was on a Java program, one of the problems I had with Java was its assertion that the programmer was too stupid to have any kind of memory safety and to do memory management. Memory management's impossible. We're going to completely take it out of the programmer's hands.
People who were building sophisticated systems in Java ended up spending all their time in memory management, namely trying to outsmart the garbage collector or feed the garbage collector. It's like, "Do you realize that the problem you're solving is just as hard as fucking [unintelligible 02:23:482."
02:23:48 Jonathan: It's actually worse because it happens in games all the time too because a lot of people use C Sharp or whatever. There's game agents like Unity that use C Sharp as its primary language. I get into these arguments with people. "You shouldn't use--" They're like, "No, garbage collection is fine just do this and that and that."
02:24:03 Bryan: You're telling me about memory management, right?
02:24:05 Jonathan: Exactly, but after you've done all those things, you still can't really prevent the garbage collector from kicking in. You never really can, especially if you use a library somewhere that you don't control. You've got a performance problem and you're doing most or more actually of the same kind of engineering. There's not the adult supervision to say, "Wait, it was an interesting idea to say that everything should be garbage collected and nobody should manage memory.
It hasn't worked out. Somebody has to do the accounting of what did we expect back when we started this idea. That the benefit would be what percentage of that benefit do we have now? It's low? Maybe that wasn't that good of an idea." We don't have anyone standing around doing that.
02:24:50 Bryan: I do think people are doing that, it's just that they're doing it in clusters and clumps. I do think that a lot of the RUST enthusiasm is people actually agreeing with that and welcoming a different approach.
02:25:03 Jonathan: I don't know whether to go off on this tangent, but the garbage collection thing, of course, people will argue about garbage collection infinitely. One of the reasons why I claim it's really turning out not to have been a good idea is in part this thing about memory being so slow, relative to CPU cycles. The only real way you can ensure that that's good is by knowing where things are in memory. People will say, "Our generation will collect or comparts things together, sometimes sarcastically.
It's like, "Actually no you can do much better as an actual programmer. That matters a lot but also our demands matter a lot. Like I said, games run at 240 hertz, how much of a GC pause can you afford to take when your frame is 4 milliseconds?
02:25:51 Bryan: Right, its not long. The memory access is going to be 100 nanoseconds. This adds up really, really quickly.
02:25:59 Jonathan: That's one reason why I like the fact that RUST went this other direction. It's like, "Okay, good. Let's start doing that." The thing that I'm concerned about there is-- I mentioned this data-oriented design thing before. One of the tenants of that is that the way that you do things fast is by operating on large groups of things.
That's just what CPUs are good at, just figure out what you're going to do, do it on this set of stuff move on to the next set of stuff. Conceptualizing things as individual actually will make your code slow. Even if you didn't spend instructions, you're missing the opportunity cost of having had this bundled together with a lot of things.
For example, some languages are predicated around memory management with automated reference counting. That's one of the big things, Swift or whatever. The C++ people are all about RAII, which stands for resource allocation is initialization, which is partially about memory, but also partially about object state. I'm not going to get into an argument about that but I believe that that has very clearly not worked out.
Again, maybe send an interesting idea for the first year really had a lot of problems. When you conceptualize things as individual like that, you're probably not going to have arrays of them. You're probably certainly not going to have different arrays with crosscutting things like those guys care about which is what you actually need to do on a CPU.
In that world, automated reference counting is not that useful unless you wrote everything behind the reference count anyway, which is what people are trying not to do. The thing that I try to explain to programmers is like, "This memory speed thing isn't going to change anytime soon--."
02:27:46 Bryan: If you're getting attacked then exactly what you're saying is, "Moores law, we're done."
02:27:51 Jonathan: Were not done, but people dont remember. Back in my first game company, we bought new computers every six months because our productivity would be 46-60, 46-90 or whatever maybe 66-90. I don't remember what the numbers were. The point is in six months you could get that much faster. That's not a thing. It changes everything.
02:28:17 Bryan: It changes everything and I think we're going to get back to an era where people are looking at what the actual artefact is generated, how that actually runs on the metal and how we can have better obstructions that allow us to better express that in terms of the running artefact. I dont know. I feel optimistic. I feel that we've gone through a bunch of experiments and that you now have--
You were saying, Where's the adult supervision? We have enough miles on the tires on some of these things that you are now seeing groups of people like, "No, we've done it that way for a long time and now actually we've seen all the problems with this."
02:28:59 Jonathan: I hope you're right. The thing is I'm relatively vocal about these things lately. Whenever I say stuff especially somewhere like Twitter, or whatever, but even in other venues I get a mixture of a lot of people telling me I'm wrong about whatever. [crosstalk]
02:29:16 Jess: Twitter is the worst place for that.
02:29:18 Jonathan: Also, then a lot of people saying, "None of that really matters because my slow React application is the future." They might actually be right to some degree.
02:29:31 Bryan: Maybe this is just fundamentally elitist but this is in my marrow, is that the number of people that are writing that software that is at the actual brain stem is a smaller number than the people that will write all software. The people that we're talking about who are writing the core of game engines, who are writing system software, it's a small number of programmers, so it's actually okay to ship that cognitive load to them.
02:30:00 Jonathan: There's a real problem though, which is the following, that the people who want to ship the slow React application a little bit do have a point in that-- What's their alternative? Make a native application that they cross-compile for all these different platforms. We have made that very, very difficult. We have made it an insane cluster F to do all those things for essentially no reason. There's just a lot of implementation details that have historically accrued. To tell somebody who can just write their high-level scripted thing, like, "Oh, you should do this native." It's a big change for them in terms of-- [crosstalk]
02:30:46 Bryan: [unintelligible 00:30:46] that important.
02:30:48 Speaker 4: Yes. Right, exactly. We need to start fixing that stuff and nobody seems very concerned about that. I just feel it's going to start at the bottom of the stack.
02:30:59 Jonathan: Possibly, yes. There's all the--
02:31:03 Speaker 4: The bridge builders as you pointed out.
02:31:05 Jonathan: Yes. I think that's a little bit happening a little bit wrong to some degree. There's a rewrite it in Rust people, which I think that's a thing that makes sense, especially when it's very well defined what the thing is.
02:31:21 Bryan: That's right, thats right.
02:31:21 Jonathan: Here's the utility, we know exactly what it is.
02:31:23 Bryan: We know what the extraction is.
02:31:24 Jonathan: We're not going to go through some prototyping phase or figuring. We want it to be more secure.
02:31:29 Bryan: We want it to be safe, secure, and high performing, and we know what it is.
02:31:35 Jonathan: Yes, that makes a lot of sense. The problem is, the things that we're rewriting in Rust is not the right thing. Unix is from 1970 and it grew, it changed a lot but we're still doing 1970 stuff 50 years later. We should have a better idea. Some of the better ideas may be things that we discounted. Microkernel was a thing for a while, and then it lost this performance argument. Microkernels are going to be slower. After all this specter and meltdown stuff, the point that I always make is look, there's 173 more of these that people just haven't found yet.
02:32:14 Bryan: That's right.
02:32:15 Jonathan: I think now that we're in this age where cores are cheap, you're just going to have the model B, your operating system gets a core and it just lives there.
02:32:23 Bryan: Yes, I think youre right.
02:32:24 Jonathan: That's the secure thing, and why not? Because you're not able to use that core anyway because we don't know how to make parallel software well enough anyway.
02:32:36 Bryan: Actually, you pointed out that the problems are just not parallel enough. We just don't have enough problems that are parallel enough, we got a lot of problems.
02:32:41 Jonathan: That's sort of what I mean by that. Has anyone done that performance comparison? Is your microkernel really slower if your non-microkernel always lives on a different CPU? I don't know. I don't know what that looks like. I'm just very concerned. I'm writing a compiler and what do you want to do?
02:33:03 Bryan: Power hit unfortunately.
02:33:06 Jonathan: Our compilation model is different. The compilation model used by C and by many other languages is that you compile your program in little pieces that are .o files. That's important for many reasons, first of all, so that you can interoperate with other languages and stuff and you can link those files together. It also lets you do incremental compilation. It also lets you do parallel compilation because you could do all these things. However, it lets you do a bad job at all those things and some of those things are not necessary. The game that we have right now, that we're working on is about 100,000 lines, so not giant, not tiny. With our compiler that's running mostly on a single core, with beyond C++ level features, what I consider to be better, C++ people might argue, but whatever, we compile that that whole game and about right now it's point nine seconds because we got-
02:33:59 Bryan: Nine milliseconds.
02:33:59 Jonathan: Yes, on one core. We compile output and output the executable, which includes spending 100 milliseconds on a link step because we output one object file then use the linker to turn it into an [inaudible 02:34:11]
02:34:10 Speaker 4: There is a Turo Pascal manual. I see it right down there. I think it's glowing hot to the touch. Remember, Turo Pascal?
02:34:18 Bryan: I had that in high school and we never wrote big things on it. It was run on Apple twos or something.
02:34:25 Speaker 4: Yes.
02:34:27 Jonathan: Among the many rants [unintelligible 02:34:29]
02:34:30 Speaker 4: [unintelligible 02:34:30] wherever he is right now just suddenly feels happy, he doesn't know why he's feeling a warm feeling.
02:34:34 Jonathan: It's insane. One of the many things that I try to get people to realize is, look, it's insane how long compilers take right now. If they're optimizing you have an excuse because you're doing combinatoric things. Just to compile a program, how big is that program as text, how many operations per second can your CPU do and so how long should it take, and why do we take orders of magnitude longer? Why does that time keep going up over time? Now, again, some languages like Rust have more of an excuse because all this correctness tracking actually is combinatorial.
Also, whether or not you should pay that every time you compile is something I disagree, but it's got a reason. Again, for most programming languages, we're compiling these things on insane supercomputers. My phone is faster than the fastest computer in the world in college that used to do nuclear simulation stuff. One of my peeves is programmers today don't understand this. They open an application on Windows, and it takes three seconds to open, and they think that that's fine.
It doesn't put anything on the screen after those three seconds, and you're like, "Do you have any idea how much your computer can do in three seconds on even one core?" We're in this world where all these design decisions are made the wrong way. I'm trying to simplify this stuff. You run the compiler, you certainly have the option of just getting an executable out the other end if you don't have any dependencies in other programming languages. It's real fast to do that. Trying to get that to work with different operating systems is really annoying. There's just a lot of friction in the-- Why?
What's an executable? It's just a well-defined file format, where some things go in certain slots. It's just data. Writing an executable file is not that different from writing a zip file or reading a JSON file, but it's become this magic scary thing that nobody is willing to do. I guess some people have made inroads on this. Doesnt the Go Compiler, can't that cross compile and generate [unintelligible 02:36:45] 
02:36:45 Jess: It's actually really nice. The other thing I like about Go is that you can create static binaries super easily.
02:36:51 Jonathan: Yes. We're going that same direction too. I think that's something Go got right that is under appreciated.
j[02:36:58] Speaker 4: That's what Rust does too. Rust generates the binaries that-- In the end I think dynamic linking maybe another one of those garbage collection kinds of things.
02:37:08 Jonathan: Dynamic linking, but even static linking. You've got this thing at the back end of how you're assembling your program. What does it mean to have a well-structured program? Its namespace, interestingly. You've got overloading, we've got whatever. You go through the link step and the first person who uses a name gets it invisibly or whatever. What? It's not a good thing to have in the back end of your infrastructure and that's just there. There's problems that I have, we have hygienic macros. In principle, if you're in the debugger, you can step into your macro and you see, okay, good. You would like that.
Problem, how do you really put that in the existing debug format? There might be a way to do it in DWARF actually, because DWARF so insane. The problem is if I set a breakpoint in that macro, I don't know where I came from now because it's on the stack. It's in the stack frame of the outer function, but I've identified that macro expansion. This maybe a hard problem to explain but the point is, I can identify this it as being in the macro, or is in the function that called the macro, but not both. I don't know DWARF well enough to know if there's a way to do that.
These things are just-- they are very complicated and they're very old. If you were to design things from scratch today, they wouldn't look like what we have. Yet there aren't very many people willing to change the things that we have. Back to the point that I brought up earlier about the point of an operating system is to help you run programs. If you install Linux today, it's insane. I have no other word than insane. Also, Windows, it's insane. My Windows machine wants to reboot itself every week. Install updates. What are the updates? They're mostly to software that I wish wasn't on my machine anyway.
02:39:15 Jess: Candy Crush, I can't get rid of Candy Crush on a Windows machine for the life of me. It's like this demon that keeps going back. I had to write a script to be a scheduled job on Windows to get rid of Candy Crush because it will come back. It just runs every so often.
02:39:29 Jonathan: We've ended up in this world. We're like that's the minimal thing that you need on your computer to run. [crosstalk]
02:39:37 Jess: It seems [unintelligible 02:39:39] it just keeps coming back. It's absolutely insane.
02:39:42 Jonathan: Meanwhile, we have this Windows that by the way has probably three nines of reliability built in now because it wants to-- Nobody even knows what nines are anymore. We've given up on that idea of things being that reliable, except maybe in corners of enterprise software. At the end of the day, I still can't render something full screen in Windows without other Windows like running to the other monitor, or like flickering back and forth and like things are still super broken or Windows, handling of high resolution displays is still super broken, and so all this complexity hasn't helped us solve the actual problems that we have.
02:40:27 Bryan: It hasn't obviously, so here's my hopeful note for the future is that I think that the abstractions when you look at Unix, a very persistent abstraction. I do think that there are there are other abstractions. I think that Rust is a very important development, I think there are there are other very important-- the sequels a very important abstraction, we develop these very important attractions and the history for behind each of those abstractions almost invariably is someone who has started to deeply question that complexity and takes a katana to it, and slices through the complexity and delivers an underlying simplicity.
I think it's like-- Then the nature of software is such that we can-- that idea, it takes one person or a small group of people to have the guts and the stamina and the resilience to do that. The way that they do that is leverage able by a much broader cross section of people.
02:41:22 Jonathan: I'm going to throw out another stone that will get people mad at me, but so in terms of all this complexity that needs to be collapsed, I think everything has its time. The thing--
02:41:34 Bryan: God, what's next? Where are you going after that?
02:41:37 Jonathan: Well, the Unix philosophy for example it has been inherited by Windows to some degree even though it's a different operating system, right? The Unix philosophy of you have all these small programs that you put together in two like Waves, I think is wrong. It's wrong for today and it was also picked up by clan nine as well and so-
02:41:58 Bryan: It's micro services, micro services are an expression of Unix philosophy, so the Unix philosophy, I've got a complicated relationship with Unix philosophy. Jess, I imagine you do too, where it's like, I love it, I love a pipeline, I love it when I want to do something that is ad hoc, that is not designed to be permanent because it allows me-- and you were getting inside this earlier about Rust for video games and why maybe it's not a fit in terms of that ability to prototype quickly, Unix philosophy great for ad hoc prototyping. [crosstalk]
02:42:28 Jess: Yes, one liners, that's one liners.
02:42:31 Jonathan: As long as what you're doing is expressible as [unintelligible 02:42:34] or something.
02:42:37 Bryan: But then doing that is great just don't make that load bearing.
02:42:40 Jonathan: Right. Well, so as somebody who likes Rust, you probably agree with me about certain things, if you're going to write a substantial program, that needs to work for a long time and it's doing sophisticated things, as we often want to do today, you want your data to be well defined and structured, you want to understand when you're dereferencing data, that it's the right type, you want to be able to move data around quickly, you want to be able to-- so all these things, right? That's what it looks like when you have a strongly typed programming language that calls out to libraries, or whatever. I don't know, crates in Rust or whatever people call things these days to do jobs.
That is the thing that we have discovered about how to put together a thing that does technical work at a large scale that does a complicated job. All this Unix stuff, it's the sort of the same thing, except instead of libraries or crates, you just have programs, and then you have like your other program that calls out to the other programs and pipes them around, which is, as far from strongly typed as you can get. Its like your data coming in a stream on a pipe. Other things about Unix that seemed cool, well, in the last point there is just to say-- we've got two levels of redundancy that are doing the same thing. Why? Get rid of that. Do that do the one that works and then if you want a looser version of that, maybe you can have a version of a language that just doesn't type check and use that for your crappy spell. There it is.
02:44:15 Bryan: I think we already have it that's Awk. I mean, this is where I love it, go use Awk if you need Awk. [crosstalk] I love Awk, I love Awk, I just said it. I'm not going to write 100 lines in Awk.
02:44:25 Jess: Oh, God. Who would do that?
02:44:26 Speaker 4: Right, exactly. Just like there's a bit of a right tool for the job.
02:44:29 Jonathan: I was more of a Perl guy/ I could see the point of something like Perl, like put all the mess in Perl, and then it just [unintelligible 02:44:35]
02:44:36 Speaker 4: Oh, God, but Perl became a super fun site. It's like we dumped so much crap into Perl that it became uninhabitable.
02:44:44 Jonathan: It went too far. [crosstalk] That's levels of redundancy that where one of the levels is not very sound, but adds a great deal of complexity. Maybe we should put those together. Another thing about Unix that like-- this is maybe getting more picky but one of the cool philosophical things was like, file descriptors, hey, this thing could be a file on disk or I could be talking over the network, isn't it so totally badass, that those are both the same thing? In a nerd kind of way, like, sure, that's great but actually, when I'm writing software, I need to know whether I'm talking over the network or to a file. I'm going to do very different things in both of those cases.
I would actually like them to be different things, because I want to know what things that I could do to one that I'm not allowed to do to another, and so forth.
02:45:36 Bryan: Yes, and I am of such mixed mind. Because it's like, it is a powerful abstraction when it works and when it breaks, it breaks badly.
02:45:46 Jonathan: Yes, it's just I think it was more powerful when it was conceived. I think for the time, 1970s, early 80s. I think that was probably the right thing, right? I don't think it's the right thing today, the problem is nobody is willing to question things at that low of a level because I think they just perceive A) it'll be way too much work to try to build a new thing from scratch. That's not like other people's things and then B) once I do that, nobody will use it and so my life will be wasted, right and the problem is, we need people who are brave. We need people to go we need like the 300 Spartans, or whatever, to go out and do something.
02:46:21 Bryan: We need people crazy enough to start a computer company.
02:46:22 Speaker 4: No, I think you're right, I think that we need people who are going to be courageous with respect to abstractions, and understand also that you can work for an abstraction that may have limited utility, but that utility can be important, that can be an important subsection, I mean, it doesn't need to be everything to everybody. I think that in fact, I think that that era needs to end. I think that we've oscillated, a couple of times into this, where everything's used to be written in Java, and then we realize like, actually shit, that's a bad idea. Some things should be written in Java, but a lot of other things shouldn't be.
Right now, I think it's like we need to accept that different domains are going to have different-- they're going to be expressed in different languages, they may have different systems, but it's not an excuse for this kind of spurious incompatibilities.
02:47:10 Jonathan: I would like to solve this. I didn't like Java, when it came out, I never really programmed in it, but again, because the people who want to do their react applications kind of have a point, I would like to figure out how do we actually solve that? What is the most technically sound thing that we could do? Where I could actually copy my program to another operating system and let's say it's not magical, let's say even have to if def around operating specific things and somehow that gets compiled into it. Then it runs, but it's like, not as managed as Java, but maybe it maps to CPU instructions.
If we did something like that, it would remove-- and I'm not actually advocating this as I'm saying it. I'm just saying like, nobody's really taking that that seriously. Maybe Java was not the right thing, but maybe something near proximal to Java would be tremendously better, it would allow us to have something very low level, like things change. Being exactly optimal in terms of CPU instruction count is not that important. All this worrying really hard about getting something into an optimal thing, not actually going to get you that much mileage today, right? But like, "Oh, we've got some bytecode that we know is pretty close to arm and pretty close to x86, and we could map it in the last stage," that's not the worst thing.
I mean, I would prefer to ship something that I compiled directly, but like, if that is what enables people to copy a program from one computer to another without having to have an installer and downloading dependencies, and then have it like, not work correctly anyway after all that, we need to start thinking about that, we really do and nobody is. I don't know.
02:48:54 Bryan: Well, I think that I'd so do you think again, I think that it's these kind of problems from which are born great and revolutionary ideas so I'm hoping that you're, I'm that DJI, J AI, whatever. I'm hoping that that's going to close beta start soon, but I'm hoping that's going to get out there.
02:49:14 Jonathan: I don't know what the timing for that will be. It's going to start small and it'll grow over time.
02:49:18 Speaker 4: Yes, that's great.
02:49:19 Bryan: I think about that's terrific. This has been an amazing conversation.
02:49:23 Jonathan: I mean, I feel like there's so much we didn't say, but that's fine.
02:49:28 Bryan: So many more rants to be had but no, I think this has been great, Jonathan.
02:49:34 Jonathan: Thanks for having me.
02:49:36 Bryan: Oh, we cannot thank you enough. This has been so much fun and it's so great, that I have to speak to someone who is not doing computing for its own sake, but actually really focused on delivering something to an end user is really terrific and refreshing, and yet still having that deep perspective.
02:49:56 Jonathan: In the same way that having to code directly to metal, there's an element of reality there. Caring what something looks like to the end user is like a different wall of the room of reality, and seeing both of those walls at once is fulfilling.
02:50:11 Bryan: It's very useful, and it's been a great conversation. Jonathan, thank you so much for joining us today.
02:50:15 Jonathan: I know. Thank you.
02:50:17 Bryan: All right. You've been listening to On the Metal: Tales from the Hardware/Software Interface. Push our notes to learn more about our guests, or to sign up for our viewing list, visit us at onthemetal.fm. On the Metal is a production of Oxide Computer Company, and is recorded in the Oxide garage in Oakland, California. To learn more about Oxide, visit us at oxide.computer.
On the Metal is hosted by me, Bryan Cantrill, along with Jess Frazelle, and we are frequently joined by our boss, Steve Tuck. Our original and awesome theme music is by JJ Weasler at Pollen Music Group. You can learn more about JJ and Pollen at pollenmusicgroup.com. We are edited and produced by Chris Hill and his crew at HumblePod. From Jess, from Steve, from me, and from all of us at Oxide Computer Company, thanks for listening to On the Metal.
[theme music]
[02:51:27] [END OF AUDIO]
